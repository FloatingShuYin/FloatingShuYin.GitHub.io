---
title: 转型计划之初级后端(下)
date: 2019-12-31 08:58:37
tags:
- 初级后端
- 转型计划
---

[Securely build, share and run any application, anywhere: docker]: https://floatsyi.com/2019/12/29/Securely-build-share-and-run-any-application-anywhere-docker/
[typescript]: https://github.com/microsoft/TypeScript
[nestjs]: https://github.com/nestjs/nest
[typeorm]: https://github.com/typeorm/typeorm
[mysql]: https://github.com/mysqljs/mysql
[docker]: https://github.com/topics/docker
[转型计划之初级后端(上)]: https://floatsyi.com/2019/12/30/%E8%BD%AC%E5%9E%8B%E8%AE%A1%E5%88%92%E4%B9%8B%E5%88%9D%E7%BA%A7%E5%90%8E%E7%AB%AF-%E4%B8%8A/
[有类型的 javascript : typescript]: https://floatsyi.com/2019/10/07/%E6%9C%89%E7%B1%BB%E5%9E%8B%E7%9A%84-javascript-typescript/
[mysql 学习笔记]: https://floatsyi.com/2019/10/12/mysql-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/
[nestjs-realworld-example-app]: https://github.com/lujakob/nestjs-realworld-example-app
[docs.nestjs.com]: https://docs.nestjs.com/
[精读 《Nestjs 文档》]: https://zhuanlan.zhihu.com/p/28621374
[yeoman]: https://yeoman.io/
[hub.docker.com: mysql]: https://hub.docker.com/_/mysql
[ts]: https://github.com/microsoft/TypeScript
[nodejs]: https://github.com/nodejs/node
[babel]: https://github.com/babel/babel
[ts-node]: https://github.com/TypeStrong/ts-node
[OpenAPI-Specification]: https://github.com/OAI/OpenAPI-Specification
[OpenAPI（Swagger）]: https://docs.nestjs.com/recipes/swagger
[typescript 的 extends 究竟有几个含义？]: https://www.zhihu.com/question/364001541


## 参考
- [转型计划之初级后端(上)][]
- [Securely build, share and run any application, anywhere: docker][]
- [有类型的 javascript : typescript][]
- [docs.nestjs.com][]
- [精读 《Nestjs 文档》][]
- [OpenAPI-Specification][]
- [OpenAPI（Swagger）][]

## 资源
- [nodejs][]
- [typescript][]
- [nestjs][]
- [typeorm][]
- [mysql][]
- [docker][]
- [nestjs-realworld-example-app][]
- [yeoman][]
- [hub.docker.com: mysql][]
- [babel][]
- [ts-node][]

## 前言
[转型计划之初级后端(上)][] 是解剖分析部分， 这篇是重构部分，利用完整的重构来检验自己是否已经达到融会贯通的程度。

## 前置知识
- [转型计划之初级后端(上)][]
- [Securely build, share and run any application, anywhere: docker][]
- [有类型的 javascript : typescript][]
- [docs.nestjs.com][]
- [OpenAPI-Specification][]

## Refactor

1. 第一步当然是要找一个好的 Boilerplate， 一般情况下是在 [yeoman][] 这个网站找
这里我在了解学习 nestjs 的过程中在 github 上发现了一个很不错的 Boilerplate: [nestjs-realworld-example-app][], 所以就决定是它了。

2. 先把 [nestjs-realworld-example-app][] `git clone https://github.com/lujakob/nestjs-realworld-example-app.git` 到本地
然后读 README.md 文档，查看开发环境是否符合要求，然后按照 README.md 文档的提示将这个 Boilerplate 运行起来, 确保没有错误发生。

3. 按照  README.md 文档的要求， 需要安装 mysql 数据库，这里我一开始是决定使用 WSL 来做这件事情， 但不久前，我看完了 docker 的文档，所以决定使用 docker 来做这件事情， 这样更符合现代的开发部署流程。
docker 的安装与使用请参考: [Securely build, share and run any application, anywhere: docker][]
在项目根目录 `mkdir mysql` `touch docker-compose.yml`
docker-compose.yml:
```yml
version: '3.1'

services:

  db:
    image: mysql
    command: --default-authentication-plugin=mysql_native_password
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: nestjsrealworld
    ports:
      - "3306:3306"
    volumes:
      - ./mysql:/var/lib/mysql

  adminer:
    image: adminer
    restart: always
    ports:
      - 8080:8080
```
  docker-compose.yml 配置文件的编写请参考: [hub.docker.com: mysql][]
  然后按照 README.md 要求 `cp ormconfig.json.example ormconfig.json`
  然后修改 ormconfig.json 内容如下:
  ```json
  {
    "type": "mysql",
    "host": "localhost",
    "port": 3306,
    "username": "root",
    "password": "rootpassword",
    "database": "nestjsrealworld",
    "entities": ["src/**/**.entity{.ts,.js}"],
    "synchronize": true
  }
  ```

4. 现在 README.md 要求的开发环境已经准备好了， 只需查看 package.json 的 script 字段
在这里加入了 `"db": "docker-compose up -d"` 一行
package.json:
```json
{
  "scripts": {
    "start": "node index.js",
    "start:watch": "nodemon",
    "prestart:prod": "tsc",
    "start:prod": "node dist/main.js",
    "test": "jest --config=jest.config.json --forceExit",
    "test:watch": "jest --watch --config=jest.config.json",
    "test:coverage": "jest --config=jest.config.json --coverage --coverageDirectory=coverage",
    "db": "docker-compose up -d"
  },
}
```
  现在先后执行 `npm run db` `npm run start`  项目就运行起来了。
  默认情况下 docker 是开机自启动的， 这样子就算你重启计算机 docker 也会自动运行你设置的 `restart: always` 容器
  因此 `npm run db` 只需要首次执行时， 执行一次即可.

5. 确保项目能够运行后， 打开入口文件 [index.js](https://sourcegraph.com/github.com/lujakob/nestjs-realworld-example-app/-/blob/index.js)
index.js
```js
/* eslint-disable */
require('ts-node/register')
require('./src/main')
```
  竟然是个 js 文件， 而不是 ts.
  可以看到这里引入了一个 [ts-node][] 的 register， 然后才是真正的入口文件 ['./src/main'](https://sourcegraph.com/github.com/lujakob/nestjs-realworld-example-app/-/blob/src/main.ts)
  如果你用过 [babel][] 的话， 你就会知道 [babel][] 也有一个 @babel/register， 可以直接运行 ES Next 的代码.
  那么这个 [ts-node][] 应该就是可以直接运行 [ts][] 的 [nodejs][] 了.
  这可是一个好东西， 所以点开 [ts-node][] 点个 star 然后继续查看真正的入口文件 ['./src/main'](https://sourcegraph.com/github.com/lujakob/nestjs-realworld-example-app/-/blob/src/main.ts)
main.ts
```ts
import { NestFactory } from '@nestjs/core'
import { ApplicationModule } from './app.module'
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger'

async function bootstrap (): Promise<void> {
  const appOptions = { cors: true }
  const app = await NestFactory.create(ApplicationModule, appOptions)
  app.setGlobalPrefix('api')

  const options = new DocumentBuilder()
    .setTitle('NestJS Realworld Example App')
    .setDescription('The Realworld API description')
    .setVersion('1.0')
    .setBasePath('api')
    .addBearerAuth()
    .build()
  const document = SwaggerModule.createDocument(app, options)
  SwaggerModule.setup('/docs', app, document)

  await app.listen(3000)
}
// eslint-disable-next-line @typescript-eslint/no-floating-promises
bootstrap()
```
  这里我们可以看到入口文件的意图很明显， 定义并执行了一个 bootstrap 函数， bootstrap 函数做了两件事情:
  1. 一个是使用 NestFactory 工厂类的静态方法 create 返回一个实现 INestApplication 接口的应用程序对象

  2. 还有一件事情是添加了一个新的路由 '/docs', 指向 Swagger UI 页面。
    Swagger UI 这里不做展开， 请参考: [OpenAPI（Swagger）][]

  值得一提的是， nest 官网文档 [docs.nestjs.com][] 说:
  > NestFactory exposes a few static methods that allow creating an application instance. The create() method returns an application object, which fulfills the INestApplication interface.

  关键字 **static methods**, 这里我看了 NestFactory 方法的实现: [github.com/nestjs/nest/-/blob/packages/core/nest-factory.ts#L252:14](https://sourcegraph.com/github.com/nestjs/nest/-/blob/packages/core/nest-factory.ts#L252:14) 发现并不是我想象的 *类 NestFactory 上定义了一个 NestFactory.create 的静态方法*，而是 NestFactory 只是类 NestFactoryStatic 的实例， 而所谓的静态方法只是 NestFactoryStatic 类的成员方法。
  可是 typescript 明明支持 static 关键字啊！！为什么要定义一个 NestFactoryStatic 类？ NestFactoryStatic类的名字里有个 Static， 所以它的成员方法就变为静态方法也是比较有意思的地方。*静态*类的成员方法简称静态方法， 很合理。哈哈。
  同样值得一提的是，静态方法 create 是一个多态方法， 这一点文档里面没有提到， 而且它的返回值竟然是一个被 new Proxy 代理包装后的对象: [github.com/nestjs/nest/-/blob/packages/core/nest-factory.ts#L228:17]:https://sourcegraph.com/github.com/nestjs/nest/-/blob/packages/core/nest-factory.ts#L228:17
  其实 NestFactory 的实现是没必要去知道的， 如果一个 api 必须看源码才能知道怎么用， 这是违反最小知识原则， 只是觉得有趣纪录一下。
  真正需要了解的是 create 的参数: appOptions, 这个时候静态类型语言的优势就体现出来了， 可以选中 create 直接按快捷键 `F12` 找到 create 的类型定义
  ```ts
  create<T extends INestApplication = INestApplication>(module: any, options?: NestApplicationOptions): Promise<T>;
  ```
  ```ts
  create<T extends INestApplication = INestApplication>(module: any, httpAdapter: AbstractHttpAdapter, options?: NestApplicationOptions): Promise<T>;
  ```

  ![typescript 的 extends 究竟有几个含义？](http://r.photo.store.qq.com/psc?/V12iDrZG1mzmnh/uMeul31pGB4ZvQm8Ou4xcT*u8NOivAaE6ZKZR46R4OifOo1ULAQJrmD8kg8MNRklCfQYyQrtsOMjAOM4y5NUwziKjnNeTnpkDycHldKVYkg!/r)
  参考: [typescript 的 extends 究竟有几个含义？][]
  options 是一个可选的， 需要尊重 NestApplicationOptions 类型的对象， 选中 NestApplicationOptions 继续按快捷键 `F12`：
  ```ts
  import { CorsOptions } from './external/cors-options.interface';
  import { HttpsOptions } from './external/https-options.interface';
  import { NestApplicationContextOptions } from './nest-application-context-options.interface';
  /**
  * @publicApi
  */
  export interface NestApplicationOptions extends NestApplicationContextOptions {
      /**
      * CORS options from [CORS package](https://github.com/expressjs/cors#configuration-options)
      */
      cors?: boolean | CorsOptions;
      /**
      * Whether to use underlying platform body parser.
      */
      bodyParser?: boolean;
      /**
      * Set of configurable HTTPS options
      */
      httpsOptions?: HttpsOptions;
  }
  ```
  写的很明白， 没什么好说的。
  入口文件分析完毕， 服务器运行在 3000 端口， 所以可以点开 http://127.0.0.1:3000/docs/ 玩玩 Swagger UI

6. 接下来就可以看一看入口文件中导入的 ['./app.module'](https://sourcegraph.com/github.com/lujakob/nestjs-realworld-example-app/-/blob/src/app.module.ts)
```ts
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { ArticleModule } from './article/article.module';
import { UserModule } from './user/user.module';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Connection } from 'typeorm';
import { ProfileModule } from './profile/profile.module';
import { TagModule } from './tag/tag.module';

@Module({
  imports: [
    TypeOrmModule.forRoot(),
    ArticleModule,
    UserModule,
    ProfileModule,
    TagModule
  ],
  controllers: [
    AppController
  ],
  providers: []
})
export class ApplicationModule {
  constructor(private readonly connection: Connection) {}
}
```
可以看到 app.module 导入了所有的业务模块（module 与 controller）， 这里可以对照一下项目结构

可以发现所有的业务模块都使用单独一个文件夹区分， 每个业务模块中都有 module controller service entity interface 和 dto， 同样的所有的单个业务模块的这些文件在 module 里面被注入。 module 是单个业务模块的中心， 而所有的业务模块都向 app.module 汇集。
从单个业务模块向入口文件看， 应用逻辑呈收敛状， 反之则呈放射状。
而且可以看到 module implements NestModule  的 configure(consumer: MiddlewareConsumer)  方法 有一个被注入的 consumer: MiddlewareConsumer
对象， 这个 consumer 对象, 可以给所有在此声明的路径与方法应用中间件。 如果要用一个词形容 module 的话， 那就是中心化。
article.module.ts
```ts
@Module({
  imports: [TypeOrmModule.forFeature([ArticleEntity, Comment, UserEntity, FollowsEntity]), UserModule],
  providers: [ArticleService],
  controllers: [
    ArticleController
  ]
})
export class ArticleModule implements NestModule {
  public configure(consumer: MiddlewareConsumer) {
    consumer
      .apply(AuthMiddleware)
      .forRoutes(
        {path: 'articles/feed', method: RequestMethod.GET},
        {path: 'articles', method: RequestMethod.POST},
        {path: 'articles/:slug', method: RequestMethod.DELETE},
        {path: 'articles/:slug', method: RequestMethod.PUT},
        {path: 'articles/:slug/comments', method: RequestMethod.POST},
        {path: 'articles/:slug/comments/:id', method: RequestMethod.DELETE},
        {path: 'articles/:slug/favorite', method: RequestMethod.POST},
        {path: 'articles/:slug/favorite', method: RequestMethod.DELETE});
  }
}
```
值得注意的是这一行中 `imports: [TypeOrmModule.forFeature([ArticleEntity, Comment, UserEntity, FollowsEntity]), UserModule],` 除了 UserModule 其他都是与数据库对应的 Entity， 这个 UserModule 的特殊之处是通过 `exports: [UserService]` 导出了 UserService (在 user.module.ts 文件中)， 使得所有 imports UserModule 的 Controller 都可以使用 UserService。 这一点(Shared modules)在 Modules 的官方文档中已经说的很清楚了: https://docs.nestjs.com/modules:
> Now any module that imports the CatsModule has access to the CatsService and will share the same instance with all other modules that import it as well.

7. module 看完后看 controller
article.controller.ts
```ts
import { Get, Post, Body, Put, Delete, Query, Param, Controller } from '@nestjs/common'
import { Request } from 'express'
import { ArticleService } from './article.service'
import { CreateArticleDto, CreateCommentDto } from './dto'
import { ArticlesRO, ArticleRO, CommentsRO } from './article.interface'

import { User } from '../user/user.decorator'

import {
  ApiUseTags,
  ApiBearerAuth,
  ApiResponse,
  ApiOperation
} from '@nestjs/swagger'

@ApiBearerAuth()
@ApiUseTags('articles')
@Controller('articles')
export class ArticleController {
  constructor (private readonly articleService: ArticleService) {}

  @ApiOperation({ title: 'Get all articles' })
  @ApiResponse({ status: 200, description: 'Return all articles.' })
  @Get()
  async findAll (@Query() query): Promise<ArticlesRO> {
    return await this.articleService.findAll(query)
  }

  @Get(':slug')
  async findOne (@Param('slug') slug): Promise<ArticleRO> {
    return await this.articleService.findOne({ slug })
  }

  @Get(':slug/comments')
  async findComments (@Param('slug') slug): Promise<CommentsRO> {
    return await this.articleService.findComments(slug)
  }

  @ApiOperation({ title: 'Create article' })
  @ApiResponse({ status: 201, description: 'The article has been successfully created.' })
  @ApiResponse({ status: 403, description: 'Forbidden.' })
  @Post()
  async create (@User('id') userId: number, @Body('article') articleData: CreateArticleDto) {
    return this.articleService.create(userId, articleData)
  }

  @ApiOperation({ title: 'Update article' })
  @ApiResponse({ status: 201, description: 'The article has been successfully updated.' })
  @ApiResponse({ status: 403, description: 'Forbidden.' })
  @Put(':slug')
  async update (@Param() params, @Body('article') articleData: CreateArticleDto) {
    // Todo: update slug also when title gets changed
    return this.articleService.update(params.slug, articleData)
  }

  @ApiOperation({ title: 'Delete article' })
  @ApiResponse({ status: 201, description: 'The article has been successfully deleted.' })
  @ApiResponse({ status: 403, description: 'Forbidden.' })
  @Delete(':slug')
  async delete (@Param() params) {
    return this.articleService.delete(params.slug)
  }

  @ApiOperation({ title: 'Create comment' })
  @ApiResponse({ status: 201, description: 'The comment has been successfully created.' })
  @ApiResponse({ status: 403, description: 'Forbidden.' })
  @Post(':slug/comments')
  async createComment (@Param('slug') slug, @Body('comment') commentData: CreateCommentDto) {
    return await this.articleService.addComment(slug, commentData)
  }

  @ApiOperation({ title: 'Delete comment' })
  @ApiResponse({ status: 201, description: 'The article has been successfully deleted.' })
  @ApiResponse({ status: 403, description: 'Forbidden.' })
  @Delete(':slug/comments/:id')
  async deleteComment (@Param() params) {
    const { slug, id } = params
    return await this.articleService.deleteComment(slug, id)
  }

  @ApiOperation({ title: 'Favorite article' })
  @ApiResponse({ status: 201, description: 'The article has been successfully favorited.' })
  @ApiResponse({ status: 403, description: 'Forbidden.' })
  @Post(':slug/favorite')
  async favorite (@User('id') userId: number, @Param('slug') slug) {
    return await this.articleService.favorite(userId, slug)
  }

  @ApiOperation({ title: 'Unfavorite article' })
  @ApiResponse({ status: 201, description: 'The article has been successfully unfavorited.' })
  @ApiResponse({ status: 403, description: 'Forbidden.' })
  @Delete(':slug/favorite')
  async unFavorite (@User('id') userId: number, @Param('slug') slug) {
    return await this.articleService.unFavorite(userId, slug)
  }

  @ApiOperation({ title: 'Get article feed' })
  @ApiResponse({ status: 200, description: 'Return article feed.' })
  @ApiResponse({ status: 403, description: 'Forbidden.' })
  @Get('feed')
  async getFeed (@User('id') userId: number, @Query() query): Promise<ArticlesRO> {
    return await this.articleService.findFeed(userId, query)
  }
}
```
在 [转型计划之初级后端(上)][] 分析的那个 [challenge-api][] 项目中， 路由注册是通过 app-routes.js 遍历一个中心化的 ['./src/routes'](https://sourcegraph.com/github.com/topcoder-platform/challenge-api/-/blob/src/routes.js#L2:4) 将 './src/controllers' 中定义的 controllers 与 './src/routes' 中定义的 routes 给一一对应这种方式实现的。
而 nest 中的 controller 却恰恰相反， 路由是完全去中心化的， 中心化的工作交给了 module 去做。
可以看到 ArticleController 的  constructor 中莫名其妙多了一个 articleService， 这是通过 module 注入进来的，即所谓的控制反转， 依赖注入。
具体请参考: https://docs.nestjs.com/controllers

8. 接下来看 Service， Service 是大部分业务逻辑的承载者。
article.service.ts
```ts
import { Injectable } from '@nestjs/common'
import { InjectRepository } from '@nestjs/typeorm'
import { Repository, getRepository, DeleteResult } from 'typeorm'
import { ArticleEntity } from './article.entity'
import { Comment } from './comment.entity'
import { UserEntity } from '../user/user.entity'
import { FollowsEntity } from '../profile/follows.entity'
import { CreateArticleDto } from './dto'

import { ArticleRO, ArticlesRO, CommentsRO } from './article.interface'
import * as slug from 'slug'

@Injectable()
export class ArticleService {
  constructor (
    @InjectRepository(ArticleEntity)
    private readonly articleRepository: Repository<ArticleEntity>,
    @InjectRepository(Comment)
    private readonly commentRepository: Repository<Comment>,
    @InjectRepository(UserEntity)
    private readonly userRepository: Repository<UserEntity>,
    @InjectRepository(FollowsEntity)
    private readonly followsRepository: Repository<FollowsEntity>
  ) {}

  async findAll (query): Promise<ArticlesRO> {
    const qb = await getRepository(ArticleEntity)
      .createQueryBuilder('article')
      .leftJoinAndSelect('article.author', 'author')

    qb.where('1 = 1')

    if ('tag' in query) {
      qb.andWhere('article.tagList LIKE :tag', { tag: `%${query.tag}%` })
    }

    if ('author' in query) {
      const author = await this.userRepository.findOne({
        username: query.author
      })
      qb.andWhere('article.authorId = :id', { id: author.id })
    }

    if ('favorited' in query) {
      const author = await this.userRepository.findOne({
        username: query.favorited
      })
      const ids = author.favorites.map(el => el.id)
      qb.andWhere('article.authorId IN (:ids)', { ids })
    }

    qb.orderBy('article.created', 'DESC')

    const articlesCount = await qb.getCount()

    if ('limit' in query) {
      qb.limit(query.limit)
    }

    if ('offset' in query) {
      qb.offset(query.offset)
    }

    const articles = await qb.getMany()

    return { articles, articlesCount }
  }

  async findFeed (userId: number, query): Promise<ArticlesRO> {
    const _follows = await this.followsRepository.find({ followerId: userId })
    const ids = _follows.map(el => el.followingId)

    const qb = await getRepository(ArticleEntity)
      .createQueryBuilder('article')
      .where('article.authorId IN (:ids)', { ids })

    qb.orderBy('article.created', 'DESC')

    const articlesCount = await qb.getCount()

    if ('limit' in query) {
      qb.limit(query.limit)
    }

    if ('offset' in query) {
      qb.offset(query.offset)
    }

    const articles = await qb.getMany()

    return { articles, articlesCount }
  }

  async findOne (where): Promise<ArticleRO> {
    const article = await this.articleRepository.findOne(where)
    return { article }
  }

  async addComment (slug: string, commentData): Promise<ArticleRO> {
    let article = await this.articleRepository.findOne({ slug })

    const comment = new Comment()
    comment.body = commentData.body

    article.comments.push(comment)

    await this.commentRepository.save(comment)
    article = await this.articleRepository.save(article)
    return { article }
  }

  async deleteComment (slug: string, id: string): Promise<ArticleRO> {
    let article = await this.articleRepository.findOne({ slug })

    const comment = await this.commentRepository.findOne(id)
    const deleteIndex = article.comments.findIndex(
      _comment => _comment.id === comment.id
    )

    if (deleteIndex >= 0) {
      const deleteComments = article.comments.splice(deleteIndex, 1)
      await this.commentRepository.delete(deleteComments[0].id)
      article = await this.articleRepository.save(article)
      return { article }
    } else {
      return { article }
    }
  }

  async favorite (id: number, slug: string): Promise<ArticleRO> {
    let article = await this.articleRepository.findOne({ slug })
    const user = await this.userRepository.findOne(id)

    const isNewFavorite =
      user.favorites.findIndex(_article => _article.id === article.id) < 0
    if (isNewFavorite) {
      user.favorites.push(article)
      article.favoriteCount++

      await this.userRepository.save(user)
      article = await this.articleRepository.save(article)
    }

    return { article }
  }

  async unFavorite (id: number, slug: string): Promise<ArticleRO> {
    let article = await this.articleRepository.findOne({ slug })
    const user = await this.userRepository.findOne(id)

    const deleteIndex = user.favorites.findIndex(
      _article => _article.id === article.id
    )

    if (deleteIndex >= 0) {
      user.favorites.splice(deleteIndex, 1)
      article.favoriteCount--

      await this.userRepository.save(user)
      article = await this.articleRepository.save(article)
    }

    return { article }
  }

  async findComments (slug: string): Promise<CommentsRO> {
    const article = await this.articleRepository.findOne({ slug })
    return { comments: article.comments }
  }

  async create (
    userId: number,
    articleData: CreateArticleDto
  ): Promise<ArticleEntity> {
    const article = new ArticleEntity()
    article.title = articleData.title
    article.description = articleData.description
    article.slug = this.slugify(articleData.title)
    article.tagList = articleData.tagList || []
    article.comments = []

    const newArticle = await this.articleRepository.save(article)

    const author = await this.userRepository.findOne({ where: { id: userId } })

    if (Array.isArray(author.articles)) {
      author.articles.push(article)
    } else {
      author.articles = [article]
    }

    await this.userRepository.save(author)

    return newArticle
  }

  async update (slug: string, articleData: any): Promise<ArticleRO> {
    const toUpdate = await this.articleRepository.findOne({ slug: slug })
    const updated = Object.assign(toUpdate, articleData)
    const article = await this.articleRepository.save(updated)
    return { article }
  }

  async delete (slug: string): Promise<DeleteResult> {
    return await this.articleRepository.delete({ slug: slug })
  }

  slugify (title: string) {
    return `${slug(title, { lower: true })}-${(
      (Math.random() * Math.pow(36, 6)) |
      0
    ).toString(36)}`
  }
}
```
可以看到， article.interface article.entity Dto 这些周边文件都是这个 article.service 的组成部分
其中 article.entity 为与数据库表一一对应实体， 可以直接根据 ER 图编写，打开 article.entity 你可以看到很多这个 @ManyToOne @OneToMany 这些注解
```ts
  @ManyToOne(type => UserEntity, user => user.articles)
  author: UserEntity;

  @OneToMany(type => Comment, comment => comment.article, { eager: true })
  @JoinColumn()
  comments: Comment[];
```
这些注解顾名思义就是描述数据库实体之间的关系， 这部分也在 ER 图中表现出来了。
而 DTO (Data Transfer Object), 可以看到都是 service 里面一些函数需要操作的数据对象， 这部分是前端传递过来的。
而 article.interface 定义了各种 RO， 所谓 RO 我的理解是 return object 的缩写。 这些都是返回给前端的数据对象。

<!-- nestjs 是一个类 Spring 框架 -->
  然后 先吃饭...
  `TODO`


