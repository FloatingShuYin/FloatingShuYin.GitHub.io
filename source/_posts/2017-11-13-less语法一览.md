---
title: less语法一览
date: 2017-11-13 11:53:36
tags:
- 笔记
- less
categories:
- 笔记
- less
---

<div class="parent">
    <div class="child">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=5175123&auto=0&height=66"></iframe>
    </div>
</div>


{% fold 点击显/隐 %}
Something
{% endfold %}


## 前言

<p>&nbsp;</p>

**本文最后迭代于(FloatingShuYin@2017-11-18 02:01:19)**

- 本文档是我学习less语法时的笔记
- 本文档内容来自于 [Less 中文网][Less.js 中文文档]以及[github.com/less/less.js][less.js]


[Less.js 中文文档]: <http://www.css88.com/doc/less/features/#features-overview-feature-variables-> (快速入门 | Less.js 中文文档)
[Less 中文网]: <http://www.lessc.cn/features/index.htm> (Less 中文网)
[less.js]: <https://github.com/less/less.js> (github.com/less/less.js)

<p>&nbsp;</p>

## 安装

`$ npm install -g less`

## 编译工具

[koala][koala]

[koala]: <http://koala-app.com/> (koala)

## 语法
### 文档头
```less
@charset "utf-8"
```

<!--more-->

### 注释

#### 缓存注释

```less
@charset "utf-8"
/*我是缓存注释，我在编译后的css文件中依然存在*/
```

#### 非缓存注释
```less
@charset "utf-8"
// 我是非缓存注释，我不会出现在编译后的css文件中
```

-------------------------------------------------------------------

</br>

### [变量(Variables)][Variables]
[Variables]: <http://www.css88.com/doc/less/features/#variables-feature> (变量(Variables))

</br>

- less中的变量声明形式是 ``@`` 符号开头，然后通过冒号`:` 赋值，分号``;`` 结尾。

如下
```less
@charset "utf-8";
@nice-blue: #5B83AD;
@light-blue: @nice-blue + #111;

#header {
  color: @light-blue;
}
```
编译成的css如下
```css
@charset "utf-8";
#header {
  color: #6c94be;
}
```

#### 变量插值（替换）(Variable Interpolation)

- 变量(Variables)还可以用在很多地方。比如说，替换选择器的名字，替换属性的名字，替换url路径，替换@import 路径等

##### 替换Selectors （选择器）
```less
// Variables（声明）
@my-selector: banner;

// Usage （使用）
.@{my-selector} {
  font-weight: bold;
  line-height: 40px;
  margin: 0 auto;
}
```
编译为:
```css
.banner {
  font-weight: bold;
  line-height: 40px;
  margin: 0 auto;
}
```

##### 替换URLs

```less
// Variables
@images: "../img";

// Usage
body {
  color: #444;
  background: url("@{images}/white-sand.png");
}
```

###### Import statements （导入语句）

```less
// Variables
@themes: "../../src/themes";

// Usage
@import "@{themes}/tidal-wave.less";

```

##### Properties （属性）

```
@property: color;

.widget {
  @{property}: #0ee;
  background-@{property}: #999;
}
```
编译为
```css
.widget {
  color: #0ee;
  background-color: #999;
}
```

##### Variable Names （变量名）

- 还可以使用变量来定义变量名(Variables name)。

如下
```less
@fnord:  "I am fnord.";
@var: "fnord";

.text {
content: @@var;
}
```
编译为
```css
.text {
  content: "I am fnord.";
}

```
简单说下，**@var** 指向字符串 **fnord**
因此 **@@var** 等同于 **@fnord**
而 **@fnord**  指向字符串 **I am fnord.**
因此  **content: @@var;** 编译为 **content: "I am fnord.";**

#####  <span id="LL"> **延迟加载(Lazy Loading**）</span>

- 延迟加载(Lazy Loading）简单说就是变量名可以先使用，后声明定义。

如下

<p>
<div style="float:left">
```less
.lazy-eval {
  width: @var;
}

@var: @a;
@a: 9%;
```
</div>
```less
.lazy-eval-scope {
  width: @var;
  @a: 9%;
}
@var: @a;
@a: 100%;
```
</p>

编译为

<p>
<div style="float:left">
```css
.lazy-eval {
  width: 9%;
}
```
</div>
```css
.lazy-eval-scope {
  width: 9%;
}
```
</p>

- 在定义一个变量两次时，只会使用最后定义的变量，Less会从当前作用域中向上搜索。这个行为类似于CSS的定义中始终使用最后定义的属性值。

如
```less
@var: 0;
.class {
  @var: 1;
  .brass {
    @var: 2;
    one: @var;
    @var: 3;
  }
  two: @var;
}

.test {
  three: @var;
}
```
编译为
```css
.class {
  two: 1;
}
.class .brass {
  one: 3;
}
.test {
  three: 0;
}
```
##### default variables （默认变量）

有时候你会用到默认变量-让你能够在没有设置某些变量的情况下设置指定的变量。这一特性并不强制要求你这么做，因为你可以很容易通过插入后定义同名变量的方式覆盖默认变量。
比如：
```less
// library
@base-color: green;
@dark-color: darken(@base-color, 10%);

// use of library
@import "library.less";
@base-color: red;
```
因为 **延迟加载** ，这上面的代码能很好的工作
其中 ``base-color`` 会被重写，而 ``dark-color``  **依然** 是暗红色。



--------------------------------------

<p>&nbsp;</p>

### [扩展（继承）(Extend)](http://www.css88.com/doc/less/features/#extend-feature)

<p>&nbsp;</p>

 > 扩展像把多个选择器合并到一个里面引用的伪类。

如
```less
 nav ul {
   &:extend(.inline);
   background: blue;
 }
```

注意上面，其中 ``&`` 符号的含义请查看  [规则集中的扩展(Extend Inside Ruleset)](#EIR)  ，如果.inline这个类没有被定义，那么就相当于 ``&:extend(.inline);`` 没写。没有任何实际效果。

以下
```less
nav ul {
  &:extend(.inline);
  background: blue;
}
.inline {
  color: red;
}
```
编译为
```css
nav ul {
  background: blue;
}
.inline,
nav ul {
  color: red;
}
```
通过对比可以很明确的发现，nav ul扩展了.inline类中 **所有被定义的属性及其值。** 具体的表现形式是直接在 **.inline** 类上加了一个 **nav ul 的选择器**

#### 扩展语法(Extend Syntax)

- 扩展要么依附于一个 **选择器**  `:extend();` ，要么放在一个 **规则集**  ``{}`` 中。
- 它看起来像一个带选择器的伪类，也可以使用 **关键字** `all`  的选择关联的选择器。

如下
```less
.a:extend(.b) {}

// the above block does the same thing as the below block
// 上面的块和下面的块效果是一样的
.a {
  &:extend(.b);
}
```
关于 **all 选择器** 的例子
如下
```less
.a:extend(.b all) {
  // extends all instances of ".b" e.g. ".x.b" or ".b.x"
  // 扩展".d"的所有实例，比如".x.d"或者".d.x"
}
.a {
  color: blue;
}
.b {
  background-color: red;
  .c {
    font-size: 10px;
  }
}

```
编译为
```css
.a {
  color: blue;
}
.b,
.a {
  background-color: red;
}
.b .c,
.a .c {
  font-size: 10px;
}
```
我们删除 **all选择器**
如下
```less
.a:extend(.b) {
  // extends only instances where the selector will be output as just ".d"
  // 只扩展了.b 这个类下面的属性及其值
}
.a {
  color: blue;
}
.b {
  background-color: red;
  .c {
    font-size: 10px;
  }
}

```
编译为
```css
.a {
  color: blue;
}
.b,
.a {
  background-color: red;
}
.b .c {
  font-size: 10px;
}
```

- 它可以包含多个要扩展的类，使用逗号分割即可。

例如:

```less
.e:extend(.f) {}
.e:extend(.g) {}

// the above an the below do the same thing
.e:extend(.f, .g) {}
```

--------------------------------------

##### **Extend attached to selector （为选择器附加扩展）**

- 给选择器附加扩展看起来就像一个普通的带参数的伪类选择器。一个选择器可以包含多个扩展分支，但是所有的扩展都必须在选择器的尾部。
  - 扩展放在选择器后面: ``pre:hover:extend(div pre)`` .
  - 在选择器和扩展中间有空格是允许的: `` pre:hover :extend(div pre)`` .
  - 允许多个选择器放一起:  ``pre:hover:extend(div pre):extend(.bucket tr)``  - 注意 这和下面的一样   ``pre:hover:extend(div pre, .bucket tr)``
  - 这样就不行 :  ``pre:hover:extend(div pre).nth-child(odd)`` . 扩展必须放到最后

如果有多个选择器,其中的任何一个都可以有extend
如下
```less
.big-division,
.big-bag:extend(.bag),
.big-bucket:extend(.bucket) {
  // body
}
```

--------------------------------------

##### **<span id="EIR">规则集中的扩展(Extend Inside Ruleset)</span>**

- 用 ``&:extend(selector)`` 语法在规则集内置入extend。. 它将快速的扩展到规则集内的每个选择器。

如
```less
pre:hover,
.some-class {
  &:extend(div pre);
}
```
相当于每个选择器后面都加上扩展:
```less
pre:hover:extend(div pre),
.some-class:extend(div pre) {}
```

--------------------------------------

##### **扩展嵌套选择器(Extending Nested Selectors)**

- extend可以匹配嵌套选择器  :

例如:
```less
.bucket {
  // nested ruleset with target selector
  // 带有目标选择器的嵌套规则集
  tr {
    color: blue;
  }
}
// nested ruleset is recognized
// 嵌套规则集是经过验证的
.some-class:extend(.bucket tr) {}
```
编译为
```css
.bucket tr,
.some-class {
  color: blue;
}
```

- 从本质上将extend会查找编译后的CSS，而不是原始的less。

如
```less
.bucket {
  tr & { // nested ruleset with target selector
    color: blue;
  }
}
.some-class:extend(tr .bucket) {} // nested ruleset is recognized
```
编译为
```css
tr .bucket,
.some-class {
  color: blue;
}
```

通过对比上面编译前后的源码，可以发现 less 先将 ``tr &`` **编译解析** 成了 ``tr .bucket`` 然后让 ``.some-class`` 这个类扩展了 ``tr .bucket`` 里定义的属性及其值 ``color: blue;``

--------------------------------------

##### **扩展中的精确匹配(Exact Matching with Extend)**

- Extend默认会在选择器之间寻找 **精确匹配**。它不管选择器是以星号开始还是不是。它也不管两个nth表达式是否具有相同的意义，它们必须以 **相同的形式匹配**。**唯一例外** 的是 **属性选择器中的引号** ，less会知道它们是相同的，然后匹配它。

例如:

```less
.a.class,
.class.a,
.class > .a {
  color: blue;
}
.test:extend(.class) {} // 以上都不匹配
```
选择器``*.class``和``.class``是等价的，而由于extend的精准匹配，不会匹配它们
如
```less
*.class {
  color: blue;
}
.noStar:extend(.class) {} // 不匹配 *.class 选择器
```

**顺序** 对于伪类相当重要，选择器``link:hover:visited`` 和 ``link:visited:hover`` 匹配相同的元素集合，**但是** extend会区别对待它们:

```less
link:hover:visited {
  color: blue;
}
.selector:extend(link:visited:hover) {}
  // 由于link:visited:hover 与 link:hover:visited 顺序不一致 所以不匹配。
```
编译为
```css
link:hover:visited {
  color: blue;
}
```

--------------------------------------

###### **用nth表示**

- 1n+3和n+3在我们大家看来是一致的，但extend并不能匹配它们。

如
```less
:nth-child(1n+3) {
  color: blue;
}
.child:extend(:nth-child(n+3)) {}
```
编译为
```CSS
:nth-child(1n+3) {
  color: blue;
}
```

- 属性选择器的引号要不要无所谓，下面这样是等价的。

```less
[title=identifier] {
  color: blue;
}
[title='identifier'] {
  color: blue;
}
[title="identifier"] {
  color: blue;
}

.noQuote:extend([title=identifier]) {}
.singleQuote:extend([title='identifier']) {}
.doubleQuote:extend([title="identifier"]) {}
```
编译为
```css
[title=identifier],
.noQuote,
.singleQuote,
.doubleQuote {
  color: blue;
}

[title='identifier'],
.noQuote,
.singleQuote,
.doubleQuote {
  color: blue;
}

[title="identifier"],
.noQuote,
.singleQuote,
.doubleQuote {
  color: blue;
}
```

--------------------------------------

##### **Extend `all`**

- 当您用less的关键字all扩展多个选择器，扩展选择器将复制和选择器所有关联的部分，扩展为一个新选择器 。

例如:
```Less
.a.b.test,
.test.c {
  color: orange;
}
.test {
  &:hover {
    color: green;
  }
}

.replacement:extend(.test all) {}
```
编译为
```css
.a.b.test,
.a.b.replacement
.test.c,
.replacement.c{
  color: orange;
}
.test:hover,
.replacement:hover{
  color: green;
}
```
**可以很明显的发现，replacement一词替换了所有的test,并且是无损的（原本的test并没有消失）**

*你可以把这种模式的操作当成无损查找替换。*

--------------------------------------

##### 扩展中的选择器插值(Selector Interpolation with Extend)

> Extend不能匹配变量选择器。如果选择器包含变量，extend会忽略它。

这是一个悬而未决的特性，改变它并不容易。然而，extend可以附加给插值选择器。

带变量的选择器不会匹配：
如
```Less
@variable: .bucket;
@{variable} { // interpolated selector // 插值选择器
  color: blue;
}
.some-class:extend(.bucket) {} // does nothing, no match is found // 找不到匹配
```
```Less
.bucket {
  color: blue;
}
.some-class:extend(@{variable}) {} // interpolated selector matches nothing
@variable: .bucket;             // 插值选择器什么也不匹配
```

上面这俩都不会匹配成功
都会编译为:
```CSS
.bucket {
  color: blue;
}
```

- 然而, :extend 附加给插值选择器是能够工作的：

如下
```less
.bucket {
  color: blue;
}
@{variable}:extend(.bucket) {}
@variable: .selector;
```
编译为
```css
.bucket,
.selector {
  color: blue;
}
```

--------------------------------------

##### 作用域/@media内的扩展(Scoping / Extend Inside @media)**

- 编写在media声明内的extend也应该只匹配同一media声明内的选择器：

如下
```less
@media print {
  .screenClass:extend(.selector) {} // extend inside media
  .selector { // this will be matched - it is in the same media
    color: black;
  }
}
.selector { // ruleset on top of style sheet - extend ignores it
  color: red;
}
@media screen {
  .selector {  // ruleset inside another media - extend ignores it
    color: blue;
  }
}
```
编译为:
```css
@media print {
  .selector,
  .screenClass { /*  ruleset inside the same media was extended */
    color: black;
  }
}
.selector { /* ruleset on top of style sheet was ignored */
  color: red;
}
@media screen {
  .selector { /* ruleset inside another media was ignored */
    color: blue;
  }
}
```

- 编写在 ``@media`` 声明内的extend不会匹配嵌套声明内的选择器：

如下
```less
@media screen {
  .screenClass:extend(.selector) {} // extend inside media
  @media (min-width: 1023px) {
    .selector {  // ruleset inside nested media - extend ignores it
      color: blue;
    }
  }
}
```
编译后:
```css
@media screen and (min-width: 1023px) {
  .selector { /* ruleset inside another nested media was ignored */
    color: blue;
  }
}
```

[css3 @media查询定？][http://www.runoob.com/try/try.php?filename=trycss3_media_example1]

- 顶级extend匹配一切，包括  ``@media``  嵌套内的选择器：

如下
```less
@media screen {
  .selector {  /* media嵌套内的规则 - 顶级extend正常工作 */
    color: blue;
  }
  @media (min-width: 1023px) {
    .selector {    /* media嵌套内的规则 - 顶级extend正常工作 */
      color: blue;
    }
  }
}

.topLevel:extend(.selector) {}  /* 顶级extend匹配一切 */
```
编译为
```CSS
@media screen {
  .selector,
  .topLevel { /* ruleset inside media was extended */
    color: blue;
  }
}
@media screen and (min-width: 1023px) {
  .selector,
  .topLevel { /* ruleset inside nested media was extended */
    color: blue;
  }
}
```

<p>&nbsp;</p>

##### **重复检测**

<p>&nbsp;</p>

-目前还没有重复检测.

例如:
```Less
.alert-info,
.widget {
  /* declarations */
  // 声明
}

.alert:extend(.alert-info, .widget) {}
```
编译为
```css
.alert-info,
.widget,
.alert,
.alert {
  /* declarations */
}
```

<p>&nbsp;</p>

#### [扩展（扩展）实例(Use Cases for Extend)](http://www.css88.com/doc/less/features/#extend-feature-use-cases-for-extend-)

<p>&nbsp;</p>

-------------------------------------------------------------

<p>&nbsp;</p>

### [mixins](http://www.css88.com/doc/less/features/#mixins-feature)（混合）

<p>&nbsp;</p>

> 从现有的样式混合（mixin）属性
- 混合就是一种将一系列属性从一个规则集引入(“混合”)到另一个规则集的方式。假设我们有以下样式:

```less
.bordered {
  border-top: dotted 1px black;
  border-bottom: solid 2px black;
}
```

- 我们希望在另一个规则集内部使用上面这些属性。那么，我们就只需要访问我们想要的属性所在类的名称即可，就像下面这样：

```less
.a, #b {
  color: red;
}
.mixin-class {
  .a();
}
.mixin-id {
  #b();
}
```
编译为：
```css
.a, #b {
  color: red;
}
.mixin-class {
  color: red;
}
.mixin-id {
  color: red;
}
```

- 在调用混合的时候可以加括号（），不加也没事，都一样。

如下
```less
.a();   //these lines do the same thing
.a;     // 这两行做同样的事情
```

#### 无输出混合集(Not Outputting the Mixin)

- 如果你想要创建一个混合集，但是却不想让它输出到你的样式中，你可以在混合集的名字后面加上一个括号。（就像是定义了一个类，并公开了构造函数)

如
```less
.my-mixin {
  color: black;
}
.my-other-mixin() {
  background: white;
}
.class {
  .my-mixin;
  .my-other-mixin;
}
```
编译为
```css
.my-mixin {
  color: black;
}
.class {
  color: black;
  background: white;
}
```

##### 带选择器的混合集Selectors in Mixins)

- 混合集不仅可以包含各种属性，而且可以包括各种选择器。

如
```less
.my-hover-mixin() {
  &:hover {
    border: 1px solid red;
  }
}
button {
  .my-hover-mixin();
}
```
编译为
```css
button:hover{
  border:1px solid red;
}
```

##### 命名空间(Namespaces)

- 如果你想要将属性混合到比较复杂的选择器中，你可以通过嵌套多层id或者class。

```less
#outer {
  .inner {
    color: red;
  }
}

.c {
  #outer > .inner;
}
```

- `>`和空格是可选的

如下
```less
// all do the same thing
// 下面所有的做的是同一件事
#outer > .inner;
#outer > .inner();
#outer .inner;
#outer .inner();
#outer.inner;
#outer.inner();
```

- 利用命名空间. 您可以把你的混合(Mixins)放在一个id选择器下，确保它不会和其它的库冲突.

如下

```less
#my-library {
  .my-mixin() {
    color: black;
  }
}
// which can be used like this
// 可以这样使用
.class {
  #my-library > .my-mixin();
}
```

##### 命名空间防护 (约束) (Guarded Namespaces)

- 如果使用命名空间约束, 混合只有在符合约束条件下（返回true时候）才会被实现。

下面2种定义是一样的

```less
@mode: a;

#namespace  when (@mode=a){
  .mixin() {
    color: blue;
  }
}

#namespace {
.mixin() when (@mode=b) {
  color: red;
 }
}

.test{#namespace > .mixin();}
```
编译为
```css
.test {
  color: blue;
}
```

因为变量 **@mode** 的值为 **a** ，所以
```
.test{#namespace > .mixin();}
```
匹配到了第一个 ``mixin``

##### **!important 关键字(The !important keyword)**

- 在mixin（混合）中使用!important关键字标识的所有的属性都将标记上!important

如
```less
.foo (@bg: #f5f5f5, @color: #900) {
  background: @bg;
  color: @color;
}
.unimportant {
  .foo();
}
.important {
  .foo() !important;
}

```
编译为
```css
.unimportant {
  background: #f5f5f5;
  color: #990000;
}
.important {
  background: #f5f5f5 !important;
  color: #990000 !important;
}
```

#### 带参数的mixins(混合)(Parametric Mixins)

- **就把mixins(混合)看作是函数就好了**

- mixins也可以接受参数，在它进行mix in操作时会将变量传递给选择器代码块。

例如:
```less
.border-radius(@radius) {
  -webkit-border-radius: @radius;
     -moz-border-radius: @radius;
          border-radius: @radius;
}
```
利用上面，我们可以组成不同的规则集:
```less
#header {
  .border-radius(4px);
}
.button {
  .border-radius(6px);
}
```
编译为
```css
#header {
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px;
}
.button {
  -webkit-border-radius: 6px;
  -moz-border-radius: 6px;
  border-radius: 6px;
}
```

- 带参数的Mixins可以有默认值

如下

```less
.border-radius(@radius: 5px) {
  -webkit-border-radius: @radius;
     -moz-border-radius: @radius;
          border-radius: @radius;
}
```
现在我们可以这么调用:
```less
#header {
  .border-radius;
}
```
编译为
```css
#header {
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}
```

- 您还可以使用不带参数的Mixins。这非常有用,如果你想隐藏CSS规则集的输出,又想在其他规则集包含它属性

如下
```less
.wrap() {
  text-wrap: wrap;
  white-space: -moz-pre-wrap;
  white-space: pre-wrap;
  word-wrap: break-word;
}

pre { .wrap }
```
编译为
```css
pre {
  text-wrap: wrap;
  white-space: -moz-pre-wrap;
  white-space: pre-wrap;
  word-wrap: break-word;
}
```

##### 带多个参数的Mixins(Mixins With Multiple Parameters )

- 多个参数可以用分号或者逗号隔开. 不过推荐使用分号. 因为逗号有两重含义: 它可以解释为混合参数的分隔符又可以解释为css列表分隔符。

- 使用逗号作为mixin的分隔符则无法用它创建逗号分割的参数列表。换句话说，如果编译器在mixin调用或者声明中看到至少一个分号，它会假设参数是由分号分割的，而所有的逗号都属于CSS列表：

1. 两个参数,每个都包含用逗号分隔的分隔表 : ``.name(1, 2, 3; something, else)``,
2. 三个参数都含有一个数字: ``.name(1, 2, 3)``,用个虚假分号来创建混合(Mixins)时css包含逗号分隔表将视其为一个参数。
3. 用逗号分隔默认值: ``.name(@param1: red, blue;)``

- 用同样的名字和参数定义混合(Mixins)是合法的。less将使用所有能用的属性(如果没有匹配上，就不能用)。
- 如果使用混合的时候只带一个参数,例如 ``.mixin(green);``,所有其它混合内的属性将强制使用它

如下
```less
.mixin(@color) {
  color-1: @color;
}
.mixin(@color; @padding: 2) {
  color-2: @color;
  padding-2: @padding;
}
.mixin(@color; @padding; @margin: 2) {
  color-3: @color;
  padding-3: @padding;
  margin: @margin @margin @margin @margin;
}
.some .selector div {
  .mixin(#008000);
}
```
编译为
```css
.some .selector div {
  color-1: #008000;
  color-2: #008000;
  padding-2: 2;
}
```
简单说一下
其中
```less
.some .selector div {
  .mixin(#008000);
}
```
只传入了 **一个参数：** ``#008000`` ，而上面的 **三个mixin（混合）** 里的 **第一个mixin** 只接受一个参： ``@color`` ，所以被 **选中调用了** ，而 **第二个mixin** 虽然有二个参： ``@color; @padding: 2`` ，但是第二个参是有默认值的，
是可选的，所以也被 **选中调用了**

##### **命名参数(Named Parameters)**

- 引用minxin时可以通过 **参数名称** 而不是 **参数的位置** 来为minxin提供参数值。
- 任何参数都可以 **通过它的名称来引用** ，这样就不必按照任意 **特定的顺序** 来使用参数

如下
```less
.mixin(@color: black; @margin: 10px; @padding: 20px) {
  color: @color;
  margin: @margin;
  padding: @padding;
}
.class1 {
  .mixin(@margin: 20px; @color: #33acfe);
}
.class2 {
  .mixin(#efca44; @padding: 40px);
}
```
其中 ``.class1``调用 ``.mixin``时传入的参：``@margin: 20px; @color: #33acfe`` 是通过通过它的名称：``@margin`` ``@color`` 来引用的。这样就不必按照任意 **特定的顺序** 来使用参数。
``.class2`` 同理

编译后的css为
```css
.class1 {
  color: #33acfe;
  margin: 20px;
  padding: 20px;
}
.class2 {
  color: #efca44;
  margin: 10px;
  padding: 40px;
}
```

</br>

##### **@arguments(@参数)变量(The @arguments Variable)**

</br>

- ``@arguments`` 在 **Mixins** 中有着特殊的意义,当调用Mixins时，它将传递所有参数。

理解为JavaScript中的 [**Arguments 对象**](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments) 就好了

```less
.box-shadow(@x: 0; @y: 0; @blur: 1px; @color: #000) {
  -webkit-box-shadow: @arguments;
     -moz-box-shadow: @arguments;
          box-shadow: @arguments;
}
.big-block {
  .box-shadow(2px; 5px);
}
```
编译为
```css
.big-block {
  -webkit-box-shadow: 2px 5px 1px #000;
     -moz-box-shadow: 2px 5px 1px #000;
          box-shadow: 2px 5px 1px #000;
}
```

<p>&emsp;</p>

##### @rest(休止)变量高级参数(Advanced Arguments and the @rest Variable)

<p>&emsp;</p>

- 如果你想用mixins **接收不定数量的参数** .你可以使用 ``...`` 在 **变量(Variables)名** 后使用，将分配它们的参数到变量(Variables)

如果把 **minxins(混合)** 看作是 **函数**
那么，其实这个``...`` 更像是JavaScript中的 **Arguments 对象**。都差不多吧，都是指代参数的集合。

如
```less
.mixin(...) {        // matches 0-N arguments  匹配 0-N个 参数
.mixin() {           // matches exactly 0 arguments  匹配 恰好  0个 参数
.mixin(@a: 1) {      // matches 0-1 arguments
.mixin(@a: 1; ...) { // matches 0-N arguments
.mixin(@a; ...) {    // matches 1-N arguments
```
此外:
```less
.mixin(@a; @rest...) {
   // @rest is bound to arguments after @a
   // @rest与@a后面的参数绑定
   // @arguments is bound to all arguments
   // 参数与所有参数绑定在一起
}
```

<p>&emsp;</p>

#####  模式匹配(Pattern-matching)

<p>&emsp;</p>

- 有时，你可能想要基于你传递给它的参数改变mixin的行为。先来看一些基础的示例：

```less
.mixin(@s; @color) { ... }

.class {
  .mixin(@switch; #888);
}
```

- 现在如果我们想基于@switch的值: ``#888`` 来定义一些不同样式的.mixin。

我们可以这样做：
```less
.mixin(dark; @color) {
  color: darken(@color, 10%);
}
.mixin(light; @color) {
  color: lighten(@color, 10%);
}
.mixin(@_; @color) {
  display: block;
}
```
如果我们运行:
```
.mixin(dark; @color) {
  color: darken(@color, 10%);
}
.mixin(light; @color) {
  color: lighten(@color, 10%);
}
.mixin(@_; @color) {
  display: block;
}

@switch: light;

.class {
  .mixin(@switch; #888);
}
```
我们将得到以下的css:
```css
.class {
  color: #a2a2a2;
  display: block;
}
```
这将会把参数： ``#888`` 传递 lightened(变淡) 的.mixin中 .如果 ``@switch`` 的值是：``dark`` 而不是：``light`` 那么将会调用 dark(变暗)的 .mixin。

这里的lightened(变淡)以及 dark(变暗)实际上指得是 这 两个函数： ``lighten(@color, 10%);``  ``darken(@color, 10%);``  的功能

- 简单说下匹配过程:
  - 第一个混合(Mixins)，因为dark是第一个参数，没有检测到它的值，所以没有匹配成功.
  - 第二个混合(Mixins)，因为检测到light的值，所以匹配成功.
  - 第三个混合(Mixins)，检测都所有值了，所以匹配成功.

**注意：只能匹配定义的过得混合（Mixins）.  **

这很好理解，就像是你只能使用声明过的变量一样。

其实，由于 [less的延迟加载机制](#LL)，你先调用mixins,然后再定义mixins也是可以通过编译的。
如下
```
@switch: light;

.class {
  .mixin(@switch; #888);
}

.mixin(dark; @color) {
  color: darken(@color, 10%);
}
.mixin(light; @color) {
  color: lighten(@color, 10%);
}
.mixin(@_; @color) {
  display: block;
}
```
仍然会编译为
```css
.class {
  color: #a2a2a2;
  display: block;
}
```
[less的延迟加载机制](#LL) 可以让我们 **先使用后定义** ，但是如果想把代码写规范 ，建议还是 **不要** 这样做的好。

- 我们也可以用多个参数匹配, 例如:
```less
.mixin(@a) {
  color: @a;
}
.mixin(@a; @b) {
  color: fade(@a; @b);
}
```
- 现在如果我们用一个参数调用.mixin , 我们将匹配到第一个.mixin, 但如果我们传递两个参数, 我们将匹配到第二个.mixin。

如果你编译以下less
```less
.mixin(@a) {
  color: @a;
}
.mixin(@a; @b) {
  color: fade(@a, @b);
}

.test {
  .mixin(#fff);
}
.testfade {
  .mixin(#fff; 10%);
}
```
你将会得到
```css
.test {
  color: #ffffff;
}
.testfade {
  color: rgba(255, 255, 255, 0.1);
}
```
如果你知道 [fade（）函数](http://www.lessc.cn/functions/index.htm#color-operations-fadeout)的作用（fade函数接收2个参，第一个是颜色，第二个是百分比透明度，返回值是，呃，如你所见，是一个rgba的css颜色表达式），通过对比就可以很明显的看出来, 由于 ``.test`` 只传了一个参，所以匹配了 **第一个mixins**，而 ``.testfade `` 传了二个参，所以匹配了 **第二个mixins**

<p>&emsp;</p>

#### [作为函数使用的Mixins(Passing Rulesets to Mixins)](http://www.css88.com/doc/less/features/#mixins-as-functions-feature)

<p>&emsp;</p>

- 所有定义在一个mixin中的变量都是可见的，还可以用于调用它的作用域中（除非调用它的作用域定义了同名变量）。

如下
```less
.mixin() {
  @width:  100%;
  @height: 200px;
}

.caller {
  .mixin();
  width:  @width;
  height: @height;
}
```
编译为
```css
.caller {
  width:  100%;
  height: 200px;
}
```

- 因此定义在mixin中的变量还可以充当它的返回值。这样就允许我们创建一个用起来类似函数的mixin。

如下
```less
.average(@x, @y) {
  @average: ((@x + @y) / 2);
}

div {
  .average(16px, 50px); // "call" the mixin
  padding: @average;    // use its "return" value
}
```
编译为
```css
div {
  padding: 33px;
}
```

- 直接定义在调用者作用域内的变量不能被重写。然而，定义变量在调用者父级作用域内的变量是不受保护的，将被重写.

如下
```less
.mixin() {
  @size: in-mixin;
  @definedOnlyInMixin: in-mixin;
}

.class {
  margin: @size @definedOnlyInMixin;
  .mixin();
}

@size: globaly-defined-value; // 调用者父级作用域 - 不受保护
```
编译为
```css
.class {
  margin: in-mixin in-mixin;
}
```
如果你还记得css的就近原则的话，这很好理解。

- 最后，定义在mixin中的mixin同样可以作为返回值

如下
```less
.unlock(@value) { // 外层的 mixin
  .doSomething() { // 被嵌套的 mixin
    declaration: @value;
  }
}

#namespace {
  .unlock(5); // unlock doSomething mixin
  .doSomething(); //嵌套混入被复制到这里，并可用
}
```
编译为
```css
#namespace {
  declaration: 5;
}
```

</br>

####  传递规则集给Mixins（Passing Rulesets to Mixins）

</br>

> 允许在mixin中定义包装的CSS块

- 分离（detached）规则集合是一组CSS属性，嵌套的规则集合，媒体声明( ``@media``)或是存储在一个变量中的任何其他东西。你可以将其包含到一个规则集合或其他结构中，它的所有属性将被复制在那里。你也可以使用它作为一个mixin参数，并传递它周围的其他任何变量。

简单示例:
```less
// 声明 detached 规则集合
@detached-ruleset: { background: red; };

// 使用 detached 规则集合
.top {
    @detached-ruleset();
}
```
编译为
```css
.top {
  background: red;
}
```

- 调用时分离（detached）规则集合后面的圆括号是必须的，而 ``@detached-ruleset;`` 这样调用是无效的。

就当创建了一个由CSS属性组成的数组好了。通过变量名加括号的方式可以获取这个数组所有的属性及其值。

- 当你希望定义一个mixin将一个媒体查询中的一个代码块或者一个浏览器不支持的类名抽象出来时很有用。规则集合可以传递规则集给mixin，所以该mixin会包装这些内容

如下
```less
// 声明一个 detached规则集：@a
@a: {background-color: green;};

// 定义一个mixin：.desktop-and-old-ie
.desktop-and-old-ie(@rules) {
  @media screen and (min-width: 1200) { @rules(); }
  html.lt-ie9 &                       { @rules(); }
}

header {
  background-color: blue;
  // 调用 .desktop-and-old-ie 把detached规则集：@a当参传过去。
  .desktop-and-old-ie({
    @a();
  });
}
```
这里的desktop-and-old-ie mixin定义了媒体查询和祖先类，因此你可以使用mixin来包装一段代码。上面这段代码会输出：

```css
header {
  background-color: blue;
}
@media screen and (min-width: 1200) {
  header {
    background-color: green;
  }
}
html.lt-ie9 header {
  background-color: green;
}
```

- 一个规则集合现在可以分配给一个变量或传递给一个mixin，并且可以包含全部的less特性

例如
```less
@my-ruleset: {
    .my-selector {
      background-color: black;
    }
  };
```

- 你甚至可以利用 媒体查询冒泡 （media query bubbling）

如下
```less
// 声明以一个 分离（detached）规则集：@my-ruleset
@my-ruleset: {
    .my-selector {
      @media tv {
        background-color: black;
      }
    }
  };
//  @media查询
@media (orientation:portrait) {
  // 调用  @my-ruleset 分离（detached）规则集
    @my-ruleset();
}
```
编译为
```css
@media (orientation: portrait) and tv {
  .my-selector {
    background-color: black;
  }
}
```

- detached规则集合可以返回它所有的mixins给调用者，可以用同样的方式调用mixin。

返回 mixin:
```less
// 声明带有mixin的分离规则集合
@detached-ruleset: {
    .mixin() {
        color:blue;
    }
};
// 调用detached规则集合
.caller {
    @detached-ruleset();
    .mixin();
}
```
编译为
```css
.caller {
  color: blue;
}
```
- 但是，它不会返回变量。

例如这个错误的示范:
```less
@detached-ruleset: {
    @color:blue; // 私有变量
};

.caller {
    @detached-ruleset();
    color: @color; // 语法错误 找不到@color的定义
}
```

</br>

----------------------------------------------

</br>

- detached规则集合可以在它 **被定义** 和 **被 调用**  的地方使用所有变量和mixins。换句话说， 定义和调用的作用域对它都是有效的。如果这两个作用域包含 **相同** 的变量或mixins，声明的作用域中的值 **优先** 。

- 定义detached规则集合体的 **声明的作用域** 是 **独立** 的。从一个变量复制detached规则集合到另一个不能修改其作用域。规则集合不会获得新的作用域，只是在那里被引用。

- detached规则集合可以通过被解锁（导入）获得到它作用域

- 真是服了，我语文没学好？

##### **定义和调用者作用域的可见性 （Definition and Caller Scope Visibility）**

独立的mixins可以调用变量和mixins：

```less
@detached-ruleset: {
  caller-variable: @callerVariable; // 这里变量是 undefined
  .callerMixin(); // 这里混合是 undefined
};

selector {
  // 使用分离规则集合
  @detached-ruleset();

  // 需要在分离规则集合内定义变量和混合
  @callerVariable: value;
  .callerMixin() {
    variable: declaration;
  }
}
```
编译为
```css
selector {
  caller-variable: value;
  variable: declaration;
}
```

- 访问形式定义的变量和混合（mixins）优先于调用者内部提供的值

```less
@variable: global;
@detached-ruleset: {
  // 将使用全局变量，因为他是访问形式定义的分离（detached）规则集合
  variable: @variable;
};

selector {
  @detached-ruleset();
  @variable: value; // 在调用者内部定义的变量 -无法作用（影响）到detached规则集合
  key: @variable;  // 在调用者内部定义的变量当然能够影响到。
}
```
编译为
```css
selector {
  variable: global;
  key: value;
}
```

##### **引用 不会 修改分离规则集合的作用域 （Referencing Won''t Modify Detached Ruleset Scope）**

- 规则集合不会获得新的作用域，只是被引用

```less
@detached-1: { scope-detached: @one @two; };
.one {
  @one: visible;
  .two {
    @detached-2: @detached-1; // 拷贝/重命名 规则集合
    @two: visible; // 规则集合不能使用visible
  }
}

.usePlace {
  .one > .two();
  @detached-2();
}
```
跑出一个错误:
```css
ERROR 1:32 The variable "@one" was not declared.
```

#### **解锁会修改分离规则集合的作用域（Unlocking Will Modify Detached Ruleset Scope）**

规则集合在解锁（导入）会获得新的作用域：

```
#space {
  .importer1() {
    @detached: { scope-detached: @variable; }; // 定义分离规则集合
  }
}

.importer2() {
  @variable: value; // 解锁分离规则集合能使用这个变量
  #space > .importer1(); // 解锁/导入分离规则集合
}

.usePlace {
  .importer2(); // 第二次解锁/导入分离规则集合
   @detached();
}
```
编译为
```CSS
.usePlace {
  scope-detached: value;
}
```

</br>

### 导入准则（Import Directives ）

</br>

> 从其他样式表中导入样式。

- 在标准的CSS中，@import必须在所有其他类型的规则之前。但是Less.js不在乎你把@import语句放在什么位置。（因为延迟加载机制）

示例：
这样是合法的
```less
.foo {
  background: #900;
}
@import "this-is-valid.less";
```

#### 文件扩展名 （File extensions）

- @import语句会通过Less依赖文件扩展名的方式区别对待不同的文件：
  1. 如果文件有一个.css扩展名，则将它作为CSS对象，同时@import语句保持不变（查看下面的inline选项）
  2. 如果有其他扩展名，则作为Less对象，然后导入它。
  3. 如果没有扩展名，则插入.less，然后将它作为Less文件导入包含进来。

示例：
```less
@import "foo";      // foo.less is imported
@import "foo.less"; // foo.less is imported
@import "foo.js";  // foo.js imported as a less file
@import "foo.css";  // statement left in place, as-is
```
下面的选项可以用来重写这一行为。**↓**

###  导入选项（Import Options）

</br>

> Less提供了一系列的CSS扩展来让你使用@import更灵活的导入第三方CSS文件。

- 语法：@import (keyword) "filename";

下面导入指令已经被实现了：

  - reference：使用Less文件但不输出
  - inline：在输出中包含源文件但不加工它
  - less：将文件作为Less文件对象，无论是什么文件扩展名
  - css：将文件作为CSS文件对象，无论是什么文件扩展名
  - once：只包含文件一次（默认行为）
  - multiple：包含文件多次

#### **reference （引用）**

> 使用@import (reference)导入外部文件，但是不添加导入的样式到编译输出中，只引用。

- reference 是Less语言中最强大的特性之一。想象以下，reference会使用一个引用标记在导入的文件中标记每个指令和选择器，正常导入它，但是生成CSS的时候，"引用的"选择器不会输出（和media query一样只包含选择器引用）。reference样式不会显示在生成的CSS中，除了应用作为mixins 或者 extended的样式。

此外，reference还依赖于使用的方法（mixin或者extend）生成不同的结果：

  1. extend：当一个选择是extended时，之后新的选择器会标记为非引用，然后将它插入引用@import语句的位置。
  2. mixins：当reference样式用作 隐性的 mixin 时，混合它的规则，标记为非引用，然后正常出现在引用它的地方。

##### **reference example （引用示例）**

- 这允许你通过做一些像下面这样的工作从诸如[Bootstrap](https://github.com/twbs/bootstrap的库中拉入特定的)，目标样式：

```
.navbar:extend(.navbar all) {}
```
这样就只会从Bootstrap中拉入.navbar相关的样式。

#### **inline**

> 使用@import (inline)引入外部文件，但不加工他们。

示例: @import (inline) "not-less-compatible.css";

当一个CSS文件可能不兼容Less的时候可以使用这一技术，这是因为尽管Less支持大多数熟知的标准的CSS，但是在有些地方它还是不支持注释，在不修改CSS的情况下它也不支持所有已知的CSS hacks。

因此你可以使用它来在输出中引入文件，最终CSS文件都会在一个地方。

####　**less**　　　

> 使用@import (less)会将导入的文件作为Less文件对象，不管文件扩展名是什么。

示例：
```less
@import (less) "foo.css";
```
#### **css**

> 使用@import (css)会将带入的文件作为普通的CSS文件对象，也不会管扩展名是什么。这意味着import语句把持不变。

示例：
```less
@import (css) "foo.less";
```
输出：
```css
@import "foo.less";
```
#### **once**

> @import语句的默认行为。这意味着文件只会被导入一次，而随后的导入文件的语句都会被忽略。

这个@import语句的默认行为。

示例：
```less
@import (once) "foo.less";
@import (once) "foo.less"; // this statement will be ignored
                          //这个声明将被忽略
```

#### **multiple**

> 使用@import (multiple)允许导入多个同名文件。这与只能导入一次的行为是对立的。

示例：
```less
// file: foo.less
.a {
  color: green;
}
// file: main.less
@import (multiple) "foo.less";
@import (multiple) "foo.less";
```
输出：
```css
.a {
  color: green;
}
.a {
  color: green;
}
```

---------------------------------

</br>

### Mixin Guards(混合约束)（护卫？门卫？）

</br>

> 带条件的mixins。

当你想要匹配表达式，而不是简单的值或者参数数量时，guard是很有用的。如果你熟悉函数式编程，那么你肯定遇到过这类问题。

- 为了尽可能的保持CSS声明的本质，Less选择实现了guarded mixins，而不是if/else语句，也就是说并不是一脉相承的实现@media查询的规范。

让我们从一个例子开始：

```less
.mixin (@a) when (lightness(@a) >= 50%) {
  background-color: black;
}
.mixin (@a) when (lightness(@a) < 50%) {
  background-color: white;
}
.mixin (@a) {
  color: @a;
}
```
这里有一个when关键字，它引进了一个guard序列（在这里只有一个guard）。现在，假设我们运行以下代码：
```less
.class1 { .mixin(#ddd) }
.class2 { .mixin(#555) }
```
会得到：
```css
.class1 {
  background-color: black;
  color: #ddd;
}
.class2 {
  background-color: white;
  color: #555;
}
```

#### Guard中的比较运算符（Guard comparison operators）

- guards中可用的比较运算符的完整列表为： >, >=, =, =<, <。此外，关键字true是让两个mixins等价的唯一真值：
```less
.truth (@a) when (@a) { ... }
.truth (@a) when (@a = true) { ... }
```
- 除了关键字true，其他任何值都是假值：

示例：
```less
.class {
  .truth(40); // 将不符合任何上述定义。
}
```
**注意，你也可以比较其他每个参数或者不使用参数**
如：
```less
@media: mobile;

.mixin (@a) when (@media = mobile) { ... }
.mixin (@a) when (@media = desktop) { ... }

.max (@a; @b) when (@a > @b) { width: @a }
.max (@a; @b) when (@a < @b) { width: @b }
```

#### 逻辑运算符 （Guard logical operatorsGuard）

- 可以在guards之间使用逻辑运算符。语法是基于CSS媒体查询。

使用and关键字来组合guards：

```less
.mixin (@a) when (@a > 10) and (@a < 20) { font-size: @a; }

.test {
  .mixin(18);
}

.test02 {
  .mixin(21);
}
```
编译为
```css
.test {
  font-size: 18;
}
```

- 可以通过用逗号 , 分隔guards来模仿 or 运算符。如果任何 guards 为 true，那么它认为是匹配的：

.mixin (@a) when (@a > 10), (@a < -10) { ... }

使用 not 关键字来否定条件：

.mixin (@b) when not (@b > 0) { ... }

####  类型检查函数（Type checking functions）

最后，如果你想基于值类型匹配mixins，那么你可以使用is函数：

```less
.mixin (@a; @b: 0) when (isnumber(@b)) { ... }
.mixin (@a; @b: black) when (iscolor(@b)) { ... }
```

- 下面是一些基本的类型检查函数：

 - iscolor
 - isnumber
 - isstring
 - iskeyword
 - isurl

- 如果你想检查一个值除了数字是否是一个特定的单位，你可以使用下列方法之一：

  - ispixel
  - ispercentage
  - isem
  - isunit

####  带条件的mixins（Conditional mixins）

**(FIXME)** 此外，**default函数** 可以用于让一个mixin匹配依赖于其他mixin匹配，然后你可以使用它来创建类似于else或者default语句（分别属于if和case结构）的“条件式mixins”：

```less
.mixin (@a) when (@a > 0) { background-color: black;}
// matches only if first mixin does not, i.e. when @a <= 0
.mixin (@a) when (default()) { background-color: while;}

.test {
  @num : 0;
  .mixin(@num);
}

.test02 {
  @num : 1;
  .mixin(@num);
}
```
编译为
```css
.test {
  background-color: while;
}
.test02 {
  background-color: black;
}
```

- 题外话
  - TODO: + 说明：
如果代码中有该标识，说明在标识处有功能代码待编写，待实现的功能在说明中会简略说明。

 - FIXME: + 说明：
如果代码中有该标识，说明标识处代码需要修正，甚至代码是错误的，不能工作，需要修复，如何修正会在说明中简略说明。

  - XXX: + 说明：
如果代码中有该标识，说明标识处代码虽然实现了功能，但是实现的方法有待商榷，希望将来能改进，要改进的地方会在说明中简略说明。

</br>

-------------------------------------

</br>

</br>

### CSS Guards（CSS 约束）

> 类似"if"形式的选择器

- 约束也适用于CSS选择器，这是一个声明mixin的语法糖，会立即调用它。

例如，在1.5.0之前你不得不这样做：
```less
.my-optional-style() when (@my-option = true) {
  button {
    color: white;
  }
}
.my-optional-style();
```

现在你可以直接在样式上编写约束:
```less
button when (@my-option = true) {
  color: white;
}
```

- 你还可以通过与``&``特性结合实现'if'类型的语句，从而允许组合多个约束。

```less
& when (@my-option = true) {
  button {
    color: white;
  }
  a {
    color: blue;
  }
}
```

-----------------------------------------------

</br>

### Loops （循环）

</br>

> 编写循环

- 在Less中，混合可以调用它自身。这样，当一个混合递归调用自己，再结合Guard表达式和模式匹配这两个特性，就可以写出循环结构。

示例：
```less
.loop(@counter) when (@counter > 0) {
  .loop((@counter - 1));    // 递归调用自身
  width: (10px * @counter); // 每次调用时产生的样式代码
}

div {
  .loop(5); // 调用循环
}
```

编译为：
```css
div {
  width: 10px;
  width: 20px;
  width: 30px;
  width: 40px;
  width: 50px;
}
```
使用递归循环最常见的情况就是生成栅格系统的CSS：
```less
.generate-columns(4);

.generate-columns(@n, @i: 1) when (@i =< @n) {
  .column-@{i} {
    width: (@i * 100% / @n);
  }
  .generate-columns(@n, (@i + 1));
}
```
编译为：
```css
.column-1 {
  width: 25%;
}
.column-2 {
  width: 50%;
}
.column-3 {
  width: 75%;
}
.column-4 {
  width: 100%;
}
```

---------------------------

</br>

### Merge （合并）

</br>

> 合并属性

- ``merge``特性可以从多个属性中将值集合到一个单一属性之下的逗号或空格分割属性列表中。对于诸如background和transform之类的属性来说，merge非常有用。

#### Comma （逗号）

</br>

> 通过逗号添加属性的值

示例：
```less
.mixin() {
  box-shadow+: inset 0 0 10px #555;
}
.myclass {
  .mixin();
  box-shadow+: 0 0 20px black;
}
```
编译为：
```css
.myclass {
  box-shadow: inset 0 0 10px #555, 0 0 20px black;
}
```

关于属性名 ``box-shadow+`` 中的加号``+``，下文有说明 **↓**

#### Space （作用域）

</br>

> 作用域内附加属性

示例:
```less
.mixin() {
  transform+_: scale(2);
}
.myclass {
  .mixin();
  transform+_: rotate(15deg);
}

输出：
```css
.myclass {
  transform: scale(2) rotate(15deg);
}
```
- 为避免任何非有意的添加，merge需要在每个待加入的声明中显示的设置一个+或者+_标记。

**注意**：尽管transform规范中属性使用空格分割，但它仍然支持使用逗号分割；这也是为什么这个特性中没有选项来配置用空格还是逗号分割的原因。

----------------------------------------

</br>

### 父级选择器（Parent Selectors ）

</br>

> 使用``&``引用父选择器

``&`` 运算符表示一个 [嵌套规则](http://www.css88.com/doc/less/features/#features-overview-feature-nested-rules-) 的父选择器，它在应用修改类或者应用伪类给现有选择器时最常用：
```less
a {
  color: blue;
  &:hover {
    color: green;
  }
}
```
结果为：
```css
a {
  color: blue;
}

a:hover {
  color: green;
}
```

**注意** ，如果上面的示例没有使用``&``，那么它的结果就是a :hover（一个匹配<a>标签内的hovered元素的后代选择器），这通常并不是我么想要的嵌套的:hover的结果。

“父选择器”有各种各样的用法。基本上，任何时候你都需要以不同的方式来组合选择器嵌套的规则，而不是默认规则。比如，一个使用&的典型的场景就是生成重复的类名：
```less
.button {
  &-ok {
    background-image: url("ok.png");
  }
  &-cancel {
    background-image: url("cancel.png");
  }

  &-custom {
    background-image: url("custom.png");
  }
}
```
输出：
```css
.button-ok {
  background-image: url("ok.png");
}
.button-cancel {
  background-image: url("cancel.png");
}
.button-custom {
  background-image: url("custom.png");
}
```

#### Multiple & （多个 &）

- ``&``可以在一个选择器中出现不止一次。这就使得它可以反复引用父选择器，而不是重复父选择器的类名。

```less
.link {
  & + & {
    color: red;
  }

  & & {
    color: green;
  }

  && {
    color: blue;
  }

  &, &ish {
    color: cyan;
  }
}
```
将输出：
```css
.link + .link {
  color: red;
}
.link .link {
  color: green;
}
.link.link {
  color: blue;
}
.link, .linkish {
  color: cyan;
}
```

- 注意，``&``代表所有的父选择器（而不只是最近的长辈）

因此下面的例子：
```less
.grand {
  .parent {
    & > & {
      color: red;
    }

    & & {
      color: green;
    }

    && {
      color: blue;
    }

    &, &ish {
      color: cyan;
    }
  }
}
```
结果为：
```css
.grand .parent > .grand .parent {
  color: red;
}
.grand .parent .grand .parent {
  color: green;
}
.grand .parent.grand .parent {
  color: blue;
}
.grand .parent,
.grand .parentish {
  color: cyan;
}
```

#### 改变选择器顺序 （Changing selector order）

- 要前置插入一个选择器给继承的(父)选择器时它是很有用的。用过将&放到当前选择器之后就可以做到这一点。

比如，使用Modernizr时，你可能希望基于要支持的特性来指定不同的规则：
```less
.header {
  .menu {
    border-radius: 5px;
    .no-borderradius & {
      background-image: url('images/button-background.png');
    }
  }
}
```
选择器.no-borderradius &会前置插入.no-borderradius给它的父选择器.header .menu，最后变成.no-borderradius .header .menu形式输出：
```css
.header .menu {
  border-radius: 5px;
}
.no-borderradius .header .menu {
  background-image: url('images/button-background.png');
}
```

#### 组合激增(Combinatorial explosion)

``&``还可以用于生成一个逗号分割列表的所有可能的选择器排列：
```less
p, a, ul, li {
  border-top: 2px dotted #366;
  & + & {
    border-top: 0;
  }
}
```
这个组合可以扩展出指定元素的所有（16种）可能的组合：
```css
p,
a,
ul,
li {
  border-top: 2px dotted #366;
}
p + p,
p + a,
p + ul,
p + li,
a + p,
a + a,
a + ul,
a + li,
ul + p,
ul + a,
ul + ul,
ul + li,
li + p,
li + a,
li + ul,
li + li {
  border-top: 0;
}
```

```js
 ██████████                █████
░░███░░░░░█               ░░███
 ░███  █ ░  ████████    ███████
 ░██████   ░░███░░███  ███░░███
 ░███░░█    ░███ ░███ ░███ ░███
 ░███ ░   █ ░███ ░███ ░███ ░███
 ██████████ ████ █████░░████████
░░░░░░░░░░ ░░░░ ░░░░░  ░░░░░░░░                      
```
