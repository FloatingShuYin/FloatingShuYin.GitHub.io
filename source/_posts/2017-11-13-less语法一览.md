---
title: less语法一览
date: 2017-11-13 11:53:36
tags:
- 笔记
- less
categories:
- 笔记
- less
---

<div style="width:300px;height:50px;margin:50px auto 150px auto">
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=5175123&auto=0&height=66"></iframe>
</div>


# 前言

**本文最后迭代于(FloatingShuYin@2017-11-17 00:17:42)**

- 本文档是我学习less语法时的笔记
- 本文档内容来自于 [Less 中文网][Less 中文网]以及[github.com/less/less.js][less.js]
- [快速入门 | Less.js 中文文档][Less.js 中文文档]
- [Less 中文网][Less 中文网]


[Less.js 中文文档]: <http://www.css88.com/doc/less/features/#features-overview-feature-variables-> (快速入门 | Less.js 中文文档)
[Less 中文网]: <http://www.lessc.cn/features/index.htm> (Less 中文网)
[less.js]: <https://github.com/less/less.js> (github.com/less/less.js)

## 安装

`$ npm install -g less`

## 编译工具

[koala][koala]

[koala]: <http://koala-app.com/> (koala)

## 语法

### 文档头

```less
@charset "utf-8"
```

<!--more-->

------------------------------------------------------------

### 注释

#### 缓存注释

```less
@charset "utf-8"
/*我是缓存注释，我在编译后的css文件中依然存在*/
```

#### 非缓存注释
```less
@charset "utf-8"
// 我是非缓存注释，我不会出现在编译后的css文件中
```

-------------------------------------------------------------------

### [变量(Variables)][Variables]
[Variables]: <http://www.lessc.cn/features/index.htm#variables-feature> (变量(Variables))

- less中的变量声明形式是 ``@`` 符号开头，然后通过分号`:` 赋值，分号``;`` 结尾。

如下
```less
@charset "utf-8";
@nice-blue: #5B83AD;
@light-blue: @nice-blue + #111;

#header {
  color: @light-blue;
}
```
编译成的css如下
```css
@charset "utf-8";
#header {
  color: #6c94be;
}
```

#### 变量替换(Variable Interpolation)

- 变量(Variables)还可以用在很多地方。比如说，替换选择器的名字，替换属性的名字，替换url路径，替换@import 路径等

##### 替换选择器
```less
// Variables（声明）
@my-selector: banner;

// Usage （使用）
.@{my-selector} {
  font-weight: bold;
  line-height: 40px;
  margin: 0 auto;
}
```
编译为:
```css
.banner {
  font-weight: bold;
  line-height: 40px;
  margin: 0 auto;
}
```

##### 替换URLs

```less
// Variables
@images: "../img";

// Usage
body {
  color: #444;
  background: url("@{images}/white-sand.png");
}
```

###### 导入说明

```less
// Variables
@themes: "../../src/themes";

// Usage
@import "@{themes}/tidal-wave.less";

```

##### 属性

```
@property: color;

.widget {
  @{property}: #0ee;
  background-@{property}: #999;
}
```
编译为
```css
.widget {
  color: #0ee;
  background-color: #999;
}
```

##### 变量名(Variable Names)

- 还可以用一个变量名定义一个变量(Variables)。

如下
```less
@fnord:  "I am fnord.";
@var: "fnord";

.text {
content: @@var;
}
```
编译为
```css
.text {
  content: "I am fnord.";
}

```
简单说下，**@var** 指向字符串 **fnord**
因此 **@@var** 等同于 **@fnord**
而 **@fnord**  指向字符串 **I am fnord.**
因此  **content: @@var;** 编译为 **content: "I am fnord.";**

#####  <span id="LL"> **延迟加载(Lazy Loading**）</span>

- 延迟加载(Lazy Loading）简单说就是变量名可以先使用，后声明并赋值。

如下

<p>
<div style="float:left">
```less
.lazy-eval {
  width: @var;
}

@var: @a;
@a: 9%;
```
</div>
```less
.lazy-eval-scope {
  width: @var;
  @a: 9%;
}
@var: @a;
@a: 100%;
```
</p>

编译为

<p>
<div style="float:left">
```css
.lazy-eval {
  width: 9%;
}
```
</div>
```css
.lazy-eval-scope {
  width: 9%;
}
```
</p>

- 当定义一个变量(Variables)两次,最后定义的那一次,影响所在作用域。这有点像css，离得最近一次定义的属性才起作用。

如
```less
@var: 0;
.class {
  @var: 1;
  .brass {
    @var: 2;
    one: @var;
    @var: 3;
  }
  two: @var;
}

.test {
  three: @var;
}
```
编译为
```css
.class {
  two: 1;
}
.class .brass {
  one: 3;
}
.test {
  three: 0;
}
```

--------------------------------------

### [继承（扩展）(Extend)](http://www.lessc.cn/features/index.htm#extend-feature)

 - 继承像把多个选择器合并到一个里面引用的伪类。


```less
 nav ul {
   &:extend(.inline);
   background: blue;
 }
```

注意上面，其中 ``&`` 符号的含义请查看  [规则集中的继承(Extend Inside Ruleset)](#EIR)  ，如果.inline这个类没有被定义，那么就相当于 ``&:extend(.inline);`` 没写。没有任何实际效果。

以下
```less
nav ul {
  &:extend(.inline);
  background: blue;
}
.inline {
  color: red;
}
```
编译为
```css
nav ul {
  background: blue;
}
.inline,
nav ul {
  color: red;
}
```
通过对比可以很明确的发现，nav ul继承了.inline类中 **所有被定义的属性及其值。** 具体的表现形式是直接在 **.inline** 类上加了一个 **nav ul 的选择器**

#### 继承语法(Extend Syntax)

- 继承要么依附于一个 **选择器**  `:extend();` ，要么放在一个 **规则集**  ``{}`` 中。
- 它看起来像一个带选择器的伪类，也可以使用 **关键字** `all`  的选择关联的选择器。

如下
```less
.a:extend(.b) {}

// the above block does the same thing as the below block
// 上面的块和下面的块效果是一样的
.a {
  &:extend(.b);
}
```
关于 **all 选择器** 的例子
如下
```less
.a:extend(.b all) {
  // extends all instances of ".b" e.g. ".x.b" or ".b.x"
  // 继承所有在 .b类中的所以子类
}
.a {
  color: blue;
}
.b {
  background-color: red;
  .c {
    font-size: 10px;
  }
}

```
编译为
```css
.a {
  color: blue;
}
.b,
.a {
  background-color: red;
}
.b .c,
.a .c {
  font-size: 10px;
}
```
我们删除 **all选择器**
如下
```less
.a:extend(.b) {
  // extends only instances where the selector will be output as just ".d"
  // 只继承了.b 这个类下面的属性及其值
}
.a {
  color: blue;
}
.b {
  background-color: red;
  .c {
    font-size: 10px;
  }
}

```
编译为
```css
.a {
  color: blue;
}
.b,
.a {
  background-color: red;
}
.b .c {
  font-size: 10px;
}
```

- 可以用逗号隔开多个类 。

例如:

```less
.e:extend(.f) {}
.e:extend(.g) {}

// the above an the below do the same thing
.e:extend(.f, .g) {}
```

--------------------------------------

##### **依附于选择器的继承(Extend Attached to Selector)**

- 依附于选择器的扩展，有点像带参数的选择器，选择器里可以包含多个扩展从句。但所有的扩展都要写在选择器的后面。
  - 扩展放在选择器后面: ``pre:hover:extend(div pre)`` .
  - 在选择器和扩展中间有空格是允许的: `` pre:hover :extend(div pre)`` .
  - 允许多个选择器放一起:  ``pre:hover:extend(div pre):extend(.bucket tr)``  - 注意 这和下面的一样   ``pre:hover:extend(div pre, .bucket tr)``
  - 这样就不行 :  ``pre:hover:extend(div pre).nth-child(odd)`` . 扩展必须放到最后

如果有多个选择器,其中的任何一个都可以有extend
如下
```less
.big-division,
.big-bag:extend(.bag),
.big-bucket:extend(.bucket) {
  // body
}
```

--------------------------------------

##### **<span id="EIR">规则集中的继承(Extend Inside Ruleset)</span>**

- 用&:extend(selector) 语法. 它将快速的扩展到规则集内的每个选择器。

如
```less
pre:hover,
.some-class {
  &:extend(div pre);
}
```
相当于每个选择器后面都加上扩展:
```less
pre:hover:extend(div pre),
.some-class:extend(div pre) {}
```

--------------------------------------

##### **继承嵌套选择器(Extending Nested Selectors)**

- 继承可以匹配嵌套选择器 . :

例如:
```less
.bucket {
  // nested ruleset with target selector
  // 带有目标选择器的嵌套规则集
  tr {
    color: blue;
  }
}
// nested ruleset is recognized
// 嵌套规则集是经过验证的
.some-class:extend(.bucket tr) {}
```
编译为
```css
.bucket tr,
.some-class {
  color: blue;
}
```

- 继承的其实是less编译后的css，而不是原本的less.

如
```less
.bucket {
  tr & { // nested ruleset with target selector
    color: blue;
  }
}
.some-class:extend(tr .bucket) {} // nested ruleset is recognized
```
编译为
```css
tr .bucket,
.some-class {
  color: blue;
}
```

通过对比上面编译前后的源码，可以发现 less 先将 ``tr &`` **编译解析** 成了 ``tr .bucket`` 然后让 ``.some-class`` 这个类继承了 ``tr .bucket`` 里定义的属性及其值 ``color: blue;``

--------------------------------------

##### **继承的精确匹配(Exact Matching with Extend)**

- 扩展默认会在选择器之间寻找 **精确匹配** ，他不管哪个选择器先使用,他不管两个nth-expressions是否有相同含义, **只有他们的形式必须一样才匹配** 。(不过有个 **例外**，**属性选择器** ,因为less知道他们有相同的形式。)

例如:

```less
.a.class,
.class.a,
.class > .a {
  color: blue;
}
.test:extend(.class) {} // 以上都不匹配
```

第一个选择器相当重要。 \*.class 和.class其实是等价的，但扩展值不匹配他们。:

```less
*.class {
  color: blue;
}
.noStar:extend(.class) {} // 不匹配 *.class 选择器
```

**顺序** 对于伪类相当重要，选择器link:hover:visited 和 link:visited:hover 相同，**但是** 继承出来就不一样啦。:

```less
link:hover:visited {
  color: blue;
}
.selector:extend(link:visited:hover) {}
  // 由于link:visited:hover 与 link:hover:visited 顺序不一致 所以不匹配。
```
编译为
```css
link:hover:visited {
  color: blue;
}
```

--------------------------------------

###### **用nth表示**

- 1n+3和n+3在我们大家看来是一致的，但继承并不能匹配它们。

如
```less
:nth-child(1n+3) {
  color: blue;
}
.child:extend(:nth-child(n+3)) {}
```
编译为
```CSS
:nth-child(1n+3) {
  color: blue;
}
```

- 属性选择器的引号要不要无所谓，下面这样是等价的。

```less
[title=identifier] {
  color: blue;
}
[title='identifier'] {
  color: blue;
}
[title="identifier"] {
  color: blue;
}

.noQuote:extend([title=identifier]) {}
.singleQuote:extend([title='identifier']) {}
.doubleQuote:extend([title="identifier"]) {}
```
编译为
```css
[title=identifier],
.noQuote,
.singleQuote,
.doubleQuote {
  color: blue;
}

[title='identifier'],
.noQuote,
.singleQuote,
.doubleQuote {
  color: blue;
}

[title="identifier"],
.noQuote,
.singleQuote,
.doubleQuote {
  color: blue;
}
```

--------------------------------------

##### **Extend `all`**

- 当您用less的关键字all扩展多个选择器，扩展选择器将复制和选择器所有关联的部分，扩展为一个新选择器 。

例如:
```Less
.a.b.test,
.test.c {
  color: orange;
}
.test {
  &:hover {
    color: green;
  }
}

.replacement:extend(.test all) {}
```
编译为
```css
.a.b.test,
.a.b.replacement
.test.c,
.replacement.c{
  color: orange;
}
.test:hover,
.replacement:hover{
  color: green;
}
```
**可以很明显的发现，replacement一词替换了所有的test,并且是无损的（原本的test并没有消失）**

*你可以把这种模式的操作当成无损查找替换。*

--------------------------------------

##### 插入选择器的扩展(Selector Interpolation with Extend)

- 继承不支持用变量(Variables)匹配选择器，如果选择器里面含有变量(Variables)，继承将会会忽视它。

如
```Less
@variable: .bucket;
@{variable} { // interpolated selector
  color: blue;
}
.some-class:extend(.bucket) {} // does nothing, no match is found
```
```Less
.bucket {
  color: blue;
}
.some-class:extend(@{variable}) {} // interpolated selector matches nothing
@variable: .bucket;
```

上面这俩都不会匹配成功
都会编译为:
```CSS
.bucket {
  color: blue;
}
```

- 不过呢, 依附于一个插入选择器 ``:extend `` 他们就可以了哦:

如下
```less
.bucket {
  color: blue;
}
@{variable}:extend(.bucket) {}
@variable: .selector;
```
编译为
```css
.bucket,
.selector {
  color: blue;
}
```

--------------------------------------

##### **``@media`` 扩展的作用域(Scoping / Extend Inside @media)**

- 扩展只匹配 ``@media`` 声明作用域内的

如下
```less
@media print {
  .screenClass:extend(.selector) {} // extend inside media
  .selector { // this will be matched - it is in the same media
    color: black;
  }
}
.selector { // ruleset on top of style sheet - extend ignores it
  color: red;
}
@media screen {
  .selector {  // ruleset inside another media - extend ignores it
    color: blue;
  }
}
```
编译为:
```css
@media print {
  .selector,
  .screenClass { /*  ruleset inside the same media was extended */
    color: black;
  }
}
.selector { /* ruleset on top of style sheet was ignored */
  color: red;
}
@media screen {
  .selector { /* ruleset inside another media was ignored */
    color: blue;
  }
}
```

- 写在 ``@media`` 内的扩展，不匹配嵌套内的选择器

如下
```less
@media screen {
  .screenClass:extend(.selector) {} // extend inside media
  @media (min-width: 1023px) {
    .selector {  // ruleset inside nested media - extend ignores it
      color: blue;
    }
  }
}
```
编译后:
```css
@media screen and (min-width: 1023px) {
  .selector { /* ruleset inside another nested media was ignored */
    color: blue;
  }
}
```

- 最外层的扩展可以匹配里面的任何，包括选择器内嵌套的 ``@media``

如下
```less
@media screen {
  .selector {  /* ruleset inside nested media - top level extend works */
    color: blue;
  }
  @media (min-width: 1023px) {
    .selector {  /* ruleset inside nested media - top level extend works */
      color: blue;
    }
  }
}

.topLevel:extend(.selector) {} /* top level extend matches everything */
```
编译为
```CSS
@media screen {
  .selector,
  .topLevel { /* ruleset inside media was extended */
    color: blue;
  }
}
@media screen and (min-width: 1023px) {
  .selector,
  .topLevel { /* ruleset inside nested media was extended */
    color: blue;
  }
}
```

##### **重复检测**

-目前还没有重复检测.

例如:
```Less
.alert-info,
.widget {
  /* declarations */
  // 声明
}

.alert:extend(.alert-info, .widget) {}
```
编译为
```css
.alert-info,
.widget,
.alert,
.alert {
  /* declarations */
}
```

#### [继承（扩展）实例(Use Cases for Extend)](http://www.lessc.cn/features/index.htm#extend-feature-use-cases-for-extend)

-------------------------------------------------------------

### [mixins](http://www.lessc.cn/features/index.htm#mixins-feature)（混合）


- 混合就是一种将一系列属性从一个规则集引入(“混合”)到另一个规则集的方式。假设我们有以下样式:

```less
.bordered {
  border-top: dotted 1px black;
  border-bottom: solid 2px black;
}
```

- 我们希望在另一个规则集内部使用上面这些属性。那么，我们就只需要访问我们想要的属性所在类的名称即可，就像下面这样：

```less
.a, #b {
  color: red;
}
.mixin-class {
  .a();
}
.mixin-id {
  #b();
}
```
编译为：
```css
.a, #b {
  color: red;
}
.mixin-class {
  color: red;
}
.mixin-id {
  color: red;
}
```

- 在调用混合的时候可以加括号（），不加也没事，都一样。

如下
```less
.a();   //these lines do the same thing
.a;     // 这两行做同样的事情
```

#### 无输出的混合(Not Outputting the Mixin)

- 如果你想创建一个混合但你不希望他输出到样式中（就像是定义了一个类，并公开了构造函数）,你可以把括号写上（注意有无括号的区别）

如
```less
.my-mixin {
  color: black;
}
.my-other-mixin() {
  background: white;
}
.class {
  .my-mixin;
  .my-other-mixin;
}
```
编译为
```css
.my-mixin {
  color: black;
}
.class {
  color: black;
  background: white;
}
```

##### 混合内的选择器(Selectors in Mixins)

- 混合不仅仅可以包含属性,他们也可以包含选择器

如
```less
.my-hover-mixin() {
  &:hover {
    border: 1px solid red;
  }
}
button {
  .my-hover-mixin();
}
```
编译为
```css
button:hover{
  border:1px solid red;
}
```

##### 命名空间(Namespaces)

- 如果你想在一个很复杂的选择器中混合(Mixins)属性,可以嵌套多个id或类。

```less
#outer {
  .inner {
    color: red;
  }
}

.c {
  #outer > .inner;
}
```

- `>`和空格是可选的

如下
```less
// all do the same thing
// 下面所有的做的是同一件事
#outer > .inner;
#outer > .inner();
#outer .inner;
#outer .inner();
#outer.inner;
#outer.inner();
```

- 利用命名空间. 您可以把你的混合(Mixins)放在一个id选择器下，确保它不会和库内的其它冲突.

如下

```less
#my-library {
  .my-mixin() {
    color: black;
  }
}
// which can be used like this
// 可以这样使用
.class {
  #my-library > .my-mixin();
}
```

##### 命名空间防护 (约束) (Guarded Namespaces)

- 如果使用命名空间约束, 混合只有在符合约束条件下（返回true时候）才会被实现。

下面2种定义是一样的

```less
@mode: a;

#namespace  when (@mode=a){
  .mixin() {
    color: blue;
  }
}

#namespace {
.mixin() when (@mode=b) {
  color: red;
 }
}

.test{#namespace > .mixin();}
```
编译为
```css
.test {
  color: blue;
}
```

因为变量 **@mode** 的值为 **a** ，所以
```
.test{#namespace > .mixin();}
```
匹配到了第一个 ``mixin``

##### **!important 关键字(The !important keyword)**

- 在mixin（混合）中使用!important关键字标识的所有的属性都将标记上!important

如
```less
.foo (@bg: #f5f5f5, @color: #900) {
  background: @bg;
  color: @color;
}
.unimportant {
  .foo();
}
.important {
  .foo() !important;
}

```
编译为
```css
.unimportant {
  background: #f5f5f5;
  color: #990000;
}
.important {
  background: #f5f5f5 !important;
  color: #990000 !important;
}
```

#### 带参数的mixins(混合)(Parametric Mixins)

- **就把mixins(混合)看作是函数就好了**

- 混合可以带参数

例如:
```less
.border-radius(@radius) {
  -webkit-border-radius: @radius;
     -moz-border-radius: @radius;
          border-radius: @radius;
}
```
利用上面，我们可以组成不同的规则集:
```less
#header {
  .border-radius(4px);
}
.button {
  .border-radius(6px);
}
```
编译为
```css
#header {
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px;
}
.button {
  -webkit-border-radius: 6px;
  -moz-border-radius: 6px;
  border-radius: 6px;
}
```

- 带参数的混合(Mixins)可以有默认值

如下

```less
.border-radius(@radius: 5px) {
  -webkit-border-radius: @radius;
     -moz-border-radius: @radius;
          border-radius: @radius;
}
```
现在我们可以这么调用:
```less
#header {
  .border-radius;
}
```
编译为
```css
#header {
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}
```

- 您还可以使用不带参数的混合(Mixins)。这非常有用,如果你想隐藏CSS规则集的输出,又想在其他规则集包含它属性

如下
```less
.wrap() {
  text-wrap: wrap;
  white-space: -moz-pre-wrap;
  white-space: pre-wrap;
  word-wrap: break-word;
}

pre { .wrap }
```
编译为
```css
pre {
  text-wrap: wrap;
  white-space: -moz-pre-wrap;
  white-space: pre-wrap;
  word-wrap: break-word;
}
```

##### 带多个参数的混合(Mixins)

- 多个参数可以用分号或者逗号隔开. 不过推荐使用分号. 因为逗号有两重含义: 它可以解释为混合参数的分隔符又可以解释为css列表分隔符。

- 两个参数,每个都包含用逗号分隔的分隔表 : ``.name(1, 2, 3; something, else)``,
- 三个参数都含有一个数字: ``.name(1, 2, 3)``,用个虚假分号来创建混合(Mixins)时css包含逗号分隔表将视其为一个参数。
- 用逗号分隔默认值: ``.name(@param1: red, blue;)``

- 用同样的名字和参数定义混合(Mixins)是合法的。less将使用所有能用的属性(如果没有匹配上，就不能用)。
- 如果使用混合的时候只带一个参数,例如 ``.mixin(green);``,所有其它混合内的属性将强制使用它

如下
```less
.mixin(@color) {
  color-1: @color;
}
.mixin(@color; @padding: 2) {
  color-2: @color;
  padding-2: @padding;
}
.mixin(@color; @padding; @margin: 2) {
  color-3: @color;
  padding-3: @padding;
  margin: @margin @margin @margin @margin;
}
.some .selector div {
  .mixin(#008000);
}
```
编译为
```css
.some .selector div {
  color-1: #008000;
  color-2: #008000;
  padding-2: 2;
}
```
简单说一下
其中
```less
.some .selector div {
  .mixin(#008000);
}
```
只传入了 **一个参数：** ``#008000`` ，而上面的 **三个mixin（混合）** 里的 **第一个mixin** 只接受一个参： ``@color`` ，所以被 **选中调用了** ，而 **第二个mixin** 虽然有二个参： ``@color; @padding: 2`` ，但是第二个参是有默认值的，
是可选的，所以也被 **选中调用了**

##### **命名参数(Named Parameters)**

- 引用minxin时可以通过 **参数名称** 而不是 **参数的位置** 来为minxin提供参数值。
- 任何参数都可以 **通过它的名称来引用** ，这样就不必按照任意 **特定的顺序** 来使用参数

如下
```less
.mixin(@color: black; @margin: 10px; @padding: 20px) {
  color: @color;
  margin: @margin;
  padding: @padding;
}
.class1 {
  .mixin(@margin: 20px; @color: #33acfe);
}
.class2 {
  .mixin(#efca44; @padding: 40px);
}
```
其中 ``.class1``调用 ``.mixin``时传入的参：``@margin: 20px; @color: #33acfe`` 是通过通过它的名称：``@margin`` ``@color`` 来引用的。这样就不必按照任意 **特定的顺序** 来使用参数。
``.class2`` 同理

编译后的css为
```css
.class1 {
  color: #33acfe;
  margin: 20px;
  padding: 20px;
}
.class2 {
  color: #efca44;
  margin: 10px;
  padding: 40px;
}
```

##### **@arguments(@参数)变量(The @arguments Variable)**

- ``@arguments`` 在 **Mixins** 中有着特殊的意义,当调用Mixins时，它将传递所有参数。

理解为JavaScript中的 [**Arguments 对象**](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments) 就好了

```less
.box-shadow(@x: 0; @y: 0; @blur: 1px; @color: #000) {
  -webkit-box-shadow: @arguments;
     -moz-box-shadow: @arguments;
          box-shadow: @arguments;
}
.big-block {
  .box-shadow(2px; 5px);
}
```
编译为
```css
.big-block {
  -webkit-box-shadow: 2px 5px 1px #000;
     -moz-box-shadow: 2px 5px 1px #000;
          box-shadow: 2px 5px 1px #000;
}
```

##### @rest(休止)变量高级参数(Advanced Arguments and the @rest Variable)

- 如果你想用mixins **接收不定数量的参数** .你可以使用 ``...`` 在 **变量(Variables)名** 后使用，将分配它们的参数到变量(Variables)

如果把 **minxins(混合)** 看作是 **函数**
那么，其实这个``...`` 更像是JavaScript中的 **Arguments 对象**。都差不多吧，都是指代参数的集合。

如
```less
.mixin(...) {        // matches 0-N arguments  匹配 0-N个 参数
.mixin() {           // matches exactly 0 arguments  匹配 恰好  0个 参数
.mixin(@a: 1) {      // matches 0-1 arguments
.mixin(@a: 1; ...) { // matches 0-N arguments
.mixin(@a; ...) {    // matches 1-N arguments
```
此外:
```less
.mixin(@a; @rest...) {
   // @rest is bound to arguments after @a
   // @rest与@a后面的参数绑定
   // @arguments is bound to all arguments
   // 参数与所有参数绑定在一起
}
```

#####  模式匹配(Pattern-matching)

- 有时, 你可能想基于参数传值改变minxins , 我们先看下基础样式:

```less
.mixin(@s; @color) { ... }

.class {
  .mixin(@switch; #888);
}
```

- 现在如果我们想基于@switch的值: ``#888`` 来定义一些不同样式的.mixin。

我们可以这样做：
```less
.mixin(dark; @color) {
  color: darken(@color, 10%);
}
.mixin(light; @color) {
  color: lighten(@color, 10%);
}
.mixin(@_; @color) {
  display: block;
}
```
如果我们运行:
```
.mixin(dark; @color) {
  color: darken(@color, 10%);
}
.mixin(light; @color) {
  color: lighten(@color, 10%);
}
.mixin(@_; @color) {
  display: block;
}

@switch: light;

.class {
  .mixin(@switch; #888);
}
```
我们将得到以下的css:
```css
.class {
  color: #a2a2a2;
  display: block;
}
```
这将会把参数： ``#888`` 传递 lightened(变淡) 的.mixin中 .如果 ``@switch`` 的值是：``dark`` 而不是：``light`` 那么将会调用 dark(变暗)的 .mixin。

这里的lightened(变淡)以及 dark(变暗)实际上指得是 这 两个函数： ``lighten(@color, 10%);``  ``darken(@color, 10%);``  的功能

- 简单说下匹配过程:
  - 第一个混合(Mixins)，因为dark是第一个参数，没有检测到它的值，所以没有匹配成功.
  - 第二个混合(Mixins)，因为检测到light的值，所以匹配成功.
  - 第三个混合(Mixins)，检测都所有值了，所以匹配成功.

**注意：只能匹配定义的过得混合（Mixins）.  **

这很好理解，就像是你只能使用声明过的变量一样。

其实，由于 [less的延迟加载机制](#LL)，你先调用mixins,然后再定义mixins也是可以通过编译的。
如下
```
@switch: light;

.class {
  .mixin(@switch; #888);
}

.mixin(dark; @color) {
  color: darken(@color, 10%);
}
.mixin(light; @color) {
  color: lighten(@color, 10%);
}
.mixin(@_; @color) {
  display: block;
}
```
仍然会编译为
```css
.class {
  color: #a2a2a2;
  display: block;
}
```
[less的延迟加载机制](#LL) 可以让我们 **先使用后定义** ，但是如果想把代码写规范 ，建议还是 **不要** 这样做的好。

- 我们也可以用多个参数匹配, 例如:
```less
.mixin(@a) {
  color: @a;
}
.mixin(@a; @b) {
  color: fade(@a; @b);
}
```
- 现在如果我们用一个参数调用.mixin , 我们将匹配到第一个.mixin, 但如果我们传递两个参数, 我们将匹配到第一个.mixin。

如果你编译以下less
```less
.mixin(@a) {
  color: @a;
}
.mixin(@a; @b) {
  color: fade(@a, @b);
}

.test {
  .mixin(#fff);
}
.testfade {
  .mixin(#fff; 10%);
}
```
你将会得到
```css
.test {
  color: #ffffff;
}
.testfade {
  color: rgba(255, 255, 255, 0.1);
}
```
如果你知道 [fade（）函数](http://www.lessc.cn/functions/index.htm#color-operations-fadeout)的作用（fade函数接收2个参，第一个是颜色，第二个是百分比透明度，返回值是，呃，如你所见，是一个rgba的css颜色表达式），通过对比就可以很明显的看出来, 由于 ``.test`` 只传了一个参，所以匹配了 **第一个mixins**，而 ``.testfade `` 传了二个参，所以匹配了 **第二个mixins**

---------------------------------------------

#### [作为函数混合(Passing Rulesets to Mixins)](http://www.lessc.cn/features/index.htm#mixins-as-functions-feature)


```js
888888  dP"Yb  8888b.   dP"Yb
  88   dP   Yb  8I  Yb dP   Yb
  88   Yb   dP  8I  dY Yb   dP
  88    YbodP  8888Y"   YbodP
```
