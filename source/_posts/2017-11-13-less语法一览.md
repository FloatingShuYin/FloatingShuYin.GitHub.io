---
title: less语法一览
date: 2017-11-13 11:53:36
tags:
- 笔记
- less
categories:
- 笔记
- less
---

<div style="width:300px;height:50px;margin:50px auto 150px auto">
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=5175123&auto=0&height=66"></iframe>
</div>


- [快速入门 | Less.js 中文文档][Less.js 中文文档]
- [Less 中文网][Less 中文网]


[Less.js 中文文档]: <http://www.css88.com/doc/less/features/#features-overview-feature-variables-> (快速入门 | Less.js 中文文档)
[Less 中文网]: <http://www.lessc.cn/features/index.htm> (Less 中文网)

## 安装

`$ npm install -g less`

## 编译工具

[koala][koala]

[koala]: <http://koala-app.com/> (koala)

## 语法

### 文档头

```less
@charset "utf-8"
```

<!--more-->

------------------------------------------------------------

### 注释

#### 缓存注释

```less
@charset "utf-8"
/*我是缓存注释，我在编译后的css文件中依然存在*/
```

#### 非缓存注释
```less
@charset "utf-8"
// 我是非缓存注释，我不会出现在编译后的css文件中
```

-------------------------------------------------------------------

### [变量(Variables)][Variables]
[Variables]: <http://www.lessc.cn/features/index.htm#variables-feature> (变量(Variables))

- less中的变量声明形式是 ``@`` 符号开头，然后通过分号`:` 赋值，分号``;`` 结尾。

如下
```less
@charset "utf-8";
@nice-blue: #5B83AD;
@light-blue: @nice-blue + #111;

#header {
  color: @light-blue;
}
```
编译成的css如下
```css
@charset "utf-8";
#header {
  color: #6c94be;
}
```

#### 变量替换(Variable Interpolation)

- 变量(Variables)还可以用在很多地方。比如说，替换选择器的名字，替换属性的名字，替换url路径，替换@import 路径等

##### 替换选择器
```less
// Variables（声明）
@my-selector: banner;

// Usage （使用）
.@{my-selector} {
  font-weight: bold;
  line-height: 40px;
  margin: 0 auto;
}
```
编译为:
```css
.banner {
  font-weight: bold;
  line-height: 40px;
  margin: 0 auto;
}
```

##### 替换URLs

```less
// Variables
@images: "../img";

// Usage
body {
  color: #444;
  background: url("@{images}/white-sand.png");
}
```

###### 导入说明

```less
// Variables
@themes: "../../src/themes";

// Usage
@import "@{themes}/tidal-wave.less";

```

##### 属性

```
@property: color;

.widget {
  @{property}: #0ee;
  background-@{property}: #999;
}
```
编译为
```css
.widget {
  color: #0ee;
  background-color: #999;
}
```

##### 变量名(Variable Names)

- 还可以用一个变量名定义一个变量(Variables)。

如下
```less
@fnord:  "I am fnord.";
@var: "fnord";

.text {
content: @@var;
}
```
编译为
```css
.text {
  content: "I am fnord.";
}

```
简单说下，**@var** 指向字符串 **fnord**
因此 **@@var** 等同于 **@fnord**
而 **@fnord**  指向字符串 **I am fnord.**
因此  **content: @@var;** 编译为 **content: "I am fnord.";**

##### 延迟加载(Lazy Loading）

- 延迟加载(Lazy Loading）简单说就是变量名可以先使用，后声明并赋值。

如下

<p>
<div style="float:left">
```less
.lazy-eval {
  width: @var;
}

@var: @a;
@a: 9%;
```
</div>
```less
.lazy-eval-scope {
  width: @var;
  @a: 9%;
}
@var: @a;
@a: 100%;
```
</p>

编译为

<p>
<div style="float:left">
```css
.lazy-eval {
  width: 9%;
}
```
</div>
```css
.lazy-eval-scope {
  width: 9%;
}
```
</p>

- 当定义一个变量(Variables)两次,最后定义的那一次,影响所在作用域。这有点像css，离得最近一次定义的属性才起作用。

如
```less
@var: 0;
.class {
  @var: 1;
  .brass {
    @var: 2;
    one: @var;
    @var: 3;
  }
  two: @var;
}

.test {
  three: @var;
}
```
编译为
```css
.class {
  two: 1;
}
.class .brass {
  one: 3;
}
.test {
  three: 0;
}
```

--------------------------------------

### [继承（扩展）(Extend)](http://www.lessc.cn/features/index.htm#extend-feature)

 - 继承像把多个选择器合并到一个里面引用的伪类。


```less
 nav ul {
   &:extend(.inline);
   background: blue;
 }
 ```

 注意上面，其中 ``&`` 符号的含义请查看  [规则集中的继承(Extend Inside Ruleset)](#EIR)  ，如果.inline这个类没有被定义，那么就相当于 ``&:extend(.inline);`` 没写。没有任何实际效果。

以下
```less
nav ul {
  &:extend(.inline);
  background: blue;
}
.inline {
  color: red;
}
```
编译为
```css
nav ul {
  background: blue;
}
.inline,
nav ul {
  color: red;
}
```
通过对比可以很明确的发现，nav ul继承了.inline类中 **所有被定义的属性及其值。** 具体的表现形式是直接在 **.inline** 类上加了一个 **nav ul 的选择器**

#### 继承语法(Extend Syntax)

- 继承要么依附于一个 **选择器**  `:extend();` ，要么放在一个 **规则集**  `{}` 中。
- 它看起来像一个带选择器的伪类，也可以使用 **关键字** `all`  的选择关联的选择器。

如下
```less
.a:extend(.b) {}

// the above block does the same thing as the below block
// 上面的块和下面的块效果是一样的
.a {
  &:extend(.b);
}
```
关于 **all 选择器** 的例子
如下
```less
.a:extend(.b all) {
  // extends all instances of ".b" e.g. ".x.b" or ".b.x"
  // 继承所有在 .b类中的所以子类
}
.a {
  color: blue;
}
.b {
  background-color: red;
  .c {
    font-size: 10px;
  }
}

```
编译为
```css
.a {
  color: blue;
}
.b,
.a {
  background-color: red;
}
.b .c,
.a .c {
  font-size: 10px;
}
```
我们删除 **all选择器**
如下
```less
.a:extend(.b) {
  // extends only instances where the selector will be output as just ".d"
  // 只继承了.b 这个类下面的属性及其值
}
.a {
  color: blue;
}
.b {
  background-color: red;
  .c {
    font-size: 10px;
  }
}

```
编译为
```css
.a {
  color: blue;
}
.b,
.a {
  background-color: red;
}
.b .c {
  font-size: 10px;
}
```

- 可以用逗号隔开多个类 。

例如:

```less
.e:extend(.f) {}
.e:extend(.g) {}

// the above an the below do the same thing
.e:extend(.f, .g) {}
```

--------------------------------------

##### **依附于选择器的继承(Extend Attached to Selector)**

- 依附于选择器的扩展，有点像带参数的选择器，选择器里可以包含多个扩展从句。但所有的扩展都要写在选择器的后面。
  - 扩展放在选择器后面: ``pre:hover:extend(div pre)`` .
  - 在选择器和扩展中间有空格是允许的: `` pre:hover :extend(div pre)`` .
  - 允许多个选择器放一起:  ``pre:hover:extend(div pre):extend(.bucket tr)``  - 注意 这和下面的一样   ``pre:hover:extend(div pre, .bucket tr)``
  - 这样就不行 :  ``pre:hover:extend(div pre).nth-child(odd)`` . 扩展必须放到最后

如果有多个选择器,其中的任何一个都可以有extend
如下
```less
.big-division,
.big-bag:extend(.bag),
.big-bucket:extend(.bucket) {
  // body
}
```

--------------------------------------

##### **<span id="EIR">规则集中的继承(Extend Inside Ruleset)</span>**

- 用&:extend(selector) 语法. 它将快速的扩展到规则集内的每个选择器。

如
```less
pre:hover,
.some-class {
  &:extend(div pre);
}
```
相当于每个选择器后面都加上扩展:
```less
pre:hover:extend(div pre),
.some-class:extend(div pre) {}
```

--------------------------------------

##### **继承嵌套选择器(Extending Nested Selectors)**

- 继承可以匹配嵌套选择器 . :

例如:
```less
.bucket {
  // nested ruleset with target selector
  // 带有目标选择器的嵌套规则集
  tr {
    color: blue;
  }
}
// nested ruleset is recognized
// 嵌套规则集是经过验证的
.some-class:extend(.bucket tr) {}
```
编译为
```css
.bucket tr,
.some-class {
  color: blue;
}
```

- 继承的其实是less编译后的css，而不是原本的less.

如
```less
.bucket {
  tr & { // nested ruleset with target selector
    color: blue;
  }
}
.some-class:extend(tr .bucket) {} // nested ruleset is recognized
```
编译为
```css
tr .bucket,
.some-class {
  color: blue;
}
```
通过对比上面编译前后的源码，可以发现 less 先将 ``tr &`` **编译解析** 成了 ``tr .bucket`` 然后让 ``.some-class`` 这个类继承了 ``tr .bucket`` 里定义的属性及其值 ``color: blue;``

--------------------------------------

##### **继承的精确匹配(Exact Matching with Extend)**

- 扩展默认会在选择器之间寻找 **精确匹配** ，他不管哪个选择器先使用,他不管两个nth-expressions是否有相同含义, **只有他们的形式必须一样才匹配** 。(不过有个 **例外**，**属性选择器** ,因为less知道他们有相同的形式。)

例如:

```less
.a.class,
.class.a,
.class > .a {
  color: blue;
}
.test:extend(.class) {} // 以上都不匹配
```

第一个选择器相当重要。 \*.class 和.class其实是等价的，但扩展值不匹配他们。:

```less
*.class {
  color: blue;
}
.noStar:extend(.class) {} // 不匹配 *.class 选择器
```

**顺序** 对于伪类相当重要，选择器link:hover:visited 和 link:visited:hover 相同，**但是** 继承出来就不一样啦。:

```less
link:hover:visited {
  color: blue;
}
.selector:extend(link:visited:hover) {}
  // 由于link:visited:hover 与 link:hover:visited 顺序不一致 所以不匹配。
```
编译为
```css
link:hover:visited {
  color: blue;
}
```

--------------------------------------

###### **用nth表示**

- 1n+3和n+3在我们大家看来是一致的，但继承并不能匹配它们。

如
```less
:nth-child(1n+3) {
  color: blue;
}
.child:extend(:nth-child(n+3)) {}
```
编译为
```CSS
:nth-child(1n+3) {
  color: blue;
}
```

- 属性选择器的引号要不要无所谓，下面这样是等价的。

```less
[title=identifier] {
  color: blue;
}
[title='identifier'] {
  color: blue;
}
[title="identifier"] {
  color: blue;
}

.noQuote:extend([title=identifier]) {}
.singleQuote:extend([title='identifier']) {}
.doubleQuote:extend([title="identifier"]) {}
```
编译为
```css
[title=identifier],
.noQuote,
.singleQuote,
.doubleQuote {
  color: blue;
}

[title='identifier'],
.noQuote,
.singleQuote,
.doubleQuote {
  color: blue;
}

[title="identifier"],
.noQuote,
.singleQuote,
.doubleQuote {
  color: blue;
}
```

--------------------------------------

##### **Extend `all`**

- 当您用less的关键字all扩展多个选择器，扩展选择器将复制和选择器所有关联的部分，扩展为一个新选择器 。

例如:
```Less
.a.b.test,
.test.c {
  color: orange;
}
.test {
  &:hover {
    color: green;
  }
}

.replacement:extend(.test all) {}
```
编译为
```css
.a.b.test,
.a.b.replacement
.test.c,
.replacement.c{
  color: orange;
}
.test:hover,
.replacement:hover{
  color: green;
}
```
**可以很明显的发现，replacement一词替换了所有的test,并且是无损的（原本的test并没有消失）**

*你可以把这种模式的操作当成无损查找替换。*

--------------------------------------

##### 插入选择器的扩展(Selector Interpolation with Extend)

- 继承不支持用变量(Variables)匹配选择器，如果选择器里面含有变量(Variables)，继承将会会忽视它。

如
```Less
@variable: .bucket;
@{variable} { // interpolated selector
  color: blue;
}
.some-class:extend(.bucket) {} // does nothing, no match is found
```
```Less
.bucket {
  color: blue;
}
.some-class:extend(@{variable}) {} // interpolated selector matches nothing
@variable: .bucket;
```

上面这俩都不会匹配成功
都会编译为:
```CSS
.bucket {
  color: blue;
}
```

- 不过呢, 依附于一个插入选择器 ``:extend `` 他们就可以了哦:

如下
```less
.bucket {
  color: blue;
}
@{variable}:extend(.bucket) {}
@variable: .selector;
```
编译为
```css
.bucket,
.selector {
  color: blue;
}
```

--------------------------------------

##### **``@media`` 扩展的作用域(Scoping / Extend Inside @media)**

- 扩展只匹配 ``@media`` 声明作用域内的

如下
```less
@media print {
  .screenClass:extend(.selector) {} // extend inside media
  .selector { // this will be matched - it is in the same media
    color: black;
  }
}
.selector { // ruleset on top of style sheet - extend ignores it
  color: red;
}
@media screen {
  .selector {  // ruleset inside another media - extend ignores it
    color: blue;
  }
}
```
编译为:
```css
@media print {
  .selector,
  .screenClass { /*  ruleset inside the same media was extended */
    color: black;
  }
}
.selector { /* ruleset on top of style sheet was ignored */
  color: red;
}
@media screen {
  .selector { /* ruleset inside another media was ignored */
    color: blue;
  }
}
```

- 写在 ``@media`` 内的扩展，不匹配嵌套内的选择器

如下
```less
@media screen {
  .screenClass:extend(.selector) {} // extend inside media
  @media (min-width: 1023px) {
    .selector {  // ruleset inside nested media - extend ignores it
      color: blue;
    }
  }
}
```
编译后:
```css
@media screen and (min-width: 1023px) {
  .selector { /* ruleset inside another nested media was ignored */
    color: blue;
  }
}
```

- 最外层的扩展可以匹配里面的任何，包括选择器内嵌套的 ``@media``

如下
```less
@media screen {
  .selector {  /* ruleset inside nested media - top level extend works */
    color: blue;
  }
  @media (min-width: 1023px) {
    .selector {  /* ruleset inside nested media - top level extend works */
      color: blue;
    }
  }
}

.topLevel:extend(.selector) {} /* top level extend matches everything */
```
编译为
```CSS
@media screen {
  .selector,
  .topLevel { /* ruleset inside media was extended */
    color: blue;
  }
}
@media screen and (min-width: 1023px) {
  .selector,
  .topLevel { /* ruleset inside nested media was extended */
    color: blue;
  }
}
```

##### **重复检测**

-目前还没有重复检测.

例如:
```Less
.alert-info,
.widget {
  /* declarations */
  // 声明
}

.alert:extend(.alert-info, .widget) {}
```
编译为
```css
.alert-info,
.widget,
.alert,
.alert {
  /* declarations */
}
```

#### [继承（扩展）实例(Use Cases for Extend)](http://www.lessc.cn/features/index.htm#extend-feature-use-cases-for-extend)

-------------------------------------------------------------

### mixins（混合）


- 混合就是一种将一系列属性从一个规则集引入(“混合”)到另一个规则集的方式。假设我们有以下样式:

```less
.bordered {
  border-top: dotted 1px black;
  border-bottom: solid 2px black;
}
```

- 我们希望在另一个规则集内部使用上面这些属性。那么，我们就只需要访问我们想要的属性所在类的名称即可，就像下面这样：

```less
#menu a {
  color: #111;
  .bordered;
}

.post a {
  color: red;
  .bordered;
}
```
编译为：
```css
.bordered {
  border-top: dotted 1px black;
  border-bottom: solid 2px black;
}
#menu a {
  color: #111;
  border-top: dotted 1px black;
  border-bottom: solid 2px black;
}
.post a {
  color: red;
  border-top: dotted 1px black;
  border-bottom: solid 2px black;
}

```

#### 带参数的mixins
