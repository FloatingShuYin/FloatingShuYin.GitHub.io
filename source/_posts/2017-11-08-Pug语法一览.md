---
title: Pug语法一览
date: 2017-11-08 11:46:50
tags:
- HEML模板引擎Pug语法一览
- 笔记
categories:
- 笔记
- Pug
---

<style>
 p > a {
    color: blue;
  }
code {
   background-color: #2d2d2d;
   color: #fdfcf8;
}  
</style>

# 写在前面的话

- 此文档是我学习Pug语法时候的练习笔记
- 此文档参考自[慕课网 Scott 带你学习Jade模板引擎课程][JadeVideo]和[Github·Pug][Pug]以及[Pugjs官网][Pugjs]
- Pug(哈巴狗)HTML模板引擎，就是原来的Jade(美玉)，听说是因为商标的原因改名了，呵呵

--------------------------------

# pug安装与测试

- **安装**
1. **pug npm package**
`$ npm install pug -g`
2. **命令行工具**
`$ npm install pug-cli -g`

- **测试**
`$ pug --help`

# 命令行编译

- 使用`pug index.pug -P -w`将index.pug 编译成html格式的文件

- 参数 `-P` 代表格式化编译后的html，便于识别。

- 参数 `-w` 代表实时编译。
<!--more-->
--------------------------------

# Atom 的pug插件
[language-pug](https://atom.io/packages/language-pug "language-pug")

--------------------------------

# Pug语法

1. pug语法相对于html语法来说：

  - **pug的标签不需要方括号`<>`**

  - **不需要结尾标签**

  - **父标签与子标签通过Tab缩进区分**

  - **标签与文本通过空格缩进区分**

下面是对比，一目了然。
新建 index.pug
- 这是 **pug源码：**
```pug
doctype html
html
  head
    title test
  body
    h1 first test
    section
    div
    p
    ul
    strong
    hr
    br
```
cd 到index.pug所在目录，使用`pug index.pug -P -w`将index.pug 编译成html格式的文件
- 这是 **编译后的html源码：**
```html
<!DOCTYPE html>
<html>
  <head>
    <title>test</title>
  </head>
  <body>
    <h1>first test</h1>
    <section></section>
    <div></div>
    <p></p>
    <ul></ul><strong></strong>
    <hr><br>
  </body>
</html>
```

使用浏览器打开编译好的index.html以查看效果

--------------------------------

## [Doctype](https://pugjs.org/language/doctype.html) (在头部的文档类型定义)

如
```
doctype html
```
编译成
```HTML
<!DOCTYPE html>
```
如需获取更多的doctype定义请点击此[链接](https://pugjs.org/language/doctype.html "Doctype")

## [标签的属性和值](https://pugjs.org/language/attributes.html)

- **在pug中同样通过`#`声明`id`,通过`.`声明`class`。不同的是多个class不需要使用空格分开，直接接在后面就可以.id与class之间同样如此。**

源码对比：

- **pug源码：**
```
doctype html
html
  head
    title#id.classname1.classname2 test
  body
    h1.classname1#id.classname2 first test
```

- **编译后的html源码：**
```html
<!DOCTYPE html>
<html>
  <head>
    <title class="classname1 classname2" id="id">test</title>
  </head>
  <body>
    <h1 class="classname1 classname2" id="id">first test</h1>
  </body>
</html>
```

- **在pug中div标签是一个特殊的存在，如果只写id或class而不写标签的话，则默认标签是div标签。**

也就是说在pug中
```
#id.classname1
```
与
```
div#id.classname1
```
是 **同样的**，同样编译成:
```html
<div class="classname1" id="id"></div>
```

### 在pug中通过小括号`()`来添加属性。

- 除了可以使用`#` `.`这些符号声明id和class这种特殊属性外
- 其他的的非特殊属性，如超链接 和 行类样式就只能通过小括号添加了.
- 不同属性之间可以通过`,`逗号分隔，也可以同html一样用` `空格分割。

如
```
a(href='#',title='titlevalue' data-uid='100') this is link
```
编译成
```HTML
<a href="#" title="titlevalue" data-uid="100">this is link</a>
```
- 有一些特殊的属性可以不通过`=`赋值

如
```
input(name='type' type='checkbox' checked)
```
编译成
```html
<input name="type" type="checkbox" checked>
```
在浏览器中的显示效果如下：
<input name="type" type="checkbox"  checked="checked">

--------------------------------------

## 混合的成段文本和标签

- 可以通过以下2中方法在大段文本中插入标签

**方法一,使用管道符号 `|` （竖线）**
如
```
p
  | 1. aa
  strong 11
  | 2. bb
  span 22
  | 3. cc
  | 4. dd
```
<span id="case2">**方法二,使用点号 `.`**</span>
```
p.
  1. aa
  <strong>11</strong>
  2. bb
  <span>22</span>
  3. cc
  4. dd
```
都会编译成
```HTML
<p>
  1. aa
  <strong>11</strong>
  2. bb
  <span>22</span>
  3. cc
  4. dd
</p>
```
在浏览器中的显示效果如下：
  1. aa
  <strong>11</strong>
  2. bb
  <span>22</span>
  3. cc
  4. dd

------------------------------------

## [注释](https://pugjs.org/language/comments.html)
### 单行注释

- 单行注释也称之为缓冲注释
- pug的单行注释同JavaScript注释一样，使用两个斜杠`//`。

如
```
// a(href='#',title='titlevalue' data-uid='100') this is link
<input name="type" type="checkbox" checked>
```
编译成
```HTML
<!-- a(href='#',title='titlevalue' data-uid='100') this is link-->
<input name="type" type="checkbox" checked>
```

### 非缓冲注释

- 只需要在单行注释的两个斜杠`//`后边加上一个短杠`-`就是所谓的非缓存注释。单行注释与非缓存注释的区别在于，使用`//-`注释的代码不会在编译后的HTML文档中留下注释`<!-- -->`,反之使用`//`注释的代码将会会在编译后的HTML文档中留下注释`<!-- -->`。

如
```
//- a(href='#',title='titlevalue' data-uid='100') this is link
<input name="type" type="checkbox" checked>
```
编译成
```HTML
<input name="type" type="checkbox" checked>
```

### 块注释
- 如果将非缓存注释放在一个元素的的父元素位置上，那么它就会成为快注释。我们可以将块注释也看成是一个元素，由于pug的元素缩进关系，块注释，将注释掉他子元素的所有子元素。而且同非缓存注释一样的，不会在编译后的HTML代码中留下注释。

如
```
input(name='type' type='checkbox' checked)
//-
  p.
    1. aa
    <strong>11</strong>
    2. bb
    <span>22</span>
    3. cc
    4. dd
h2 块注释
```
编译成
```HTML
<input name="type" type="checkbox" checked>
<h2>块注释</h2>
```

### 条件注释

- Pug对条件注释没有任何特殊的语法。（条件注释是为旧版本的 ie 浏览器添加回退标记的奇特方法。）
- 由于所有方括号 `<` 开始的行都被视为纯文本, 所以正常的 HTML样式的条件注释会很好地工作

如
```
doctype html

<!--[if IE 8]>
<html lang="en" class="lt-ie9">
<![endif]-->
<!--[if gt IE 8]><!-->
<html lang="en">
<!--<![endif]-->

body
  p Supporting old web browsers is a pain.

</html>
```
编译成
```HTML
<!DOCTYPE html>
<!--[if IE 8]>
<html lang="en" class="lt-ie9">
<![endif]-->
<!--[if gt IE 8]><!-->
<html lang="en">
<!--<![endif]-->

<body>
  <p>Supporting old web browsers is a pain.</p>
</body>

</html>
```

-----------------------------

## 脚本与样式

- 我们可以在元素后加`.`小数点然后接空格的方式来向大段文本中[插入HTML原生标签](#case2)。同样的我们也可以用这种语法实现插入原生的CSS样式，以及Javascript脚本

pug代码如下：
```
doctype html
html
  head
    meta(charset='utf8')
    title test
  body
    style.
      body {
        color:#ff6600
      }
    script.
        var titlename = '我是标题';
    h1 first test

```
编译后的HTML代码如下：
```HTML
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf8">
    <title>test</title>
  </head>
  <body>
    <style>
      body {
        color:#ff6600
      }
    </style>
    <script>var titlename = '我是标题';</script>
    <h1>first test</h1>
  </body>
</html>
```

--------------------------------

## 变量声明和数据传递

- 声明变量只需在var 前面加`-`短杠然后接空格。

如下
```
- var hw = 'Hello World'
```

- 使用变量有两种形式： `#{变量名}` `元素名= 变量名`

** 推荐使用 `元素名= 变量名` 这种形式**

如下
```
doctype html
html
  head
    meta(charset='utf8')
    //- 声明变量
    - var hw = 'Hello World'
    - var title = '变量声明和数据传递'
    //- 使用变量
    title #{title}
  body
    //- 使用变量并调用小写转大写方法    
    h1= hw.toUpperCase()

```

编译后
```HTML
<html>
  <head>
    <meta charset="utf8">
    <title>变量声明和数据传递</title>
  </head>
  <body>
    <h1>HELLO WORLD</h1>
  </body>
</html>
```

- **变量的优先级遵循从近原则，即外部引入的变量会被内部声明的同名变量替换**

--------------------------------

## 命令行读取Json文件

- 在index.pug同级目录新建test.json

**test.json** 如下
~~~JSON
{
  "title": "命令行读取Json文件",
  "hw" : "Hello World"
}
~~~
**index.pug** 如下
```
doctype html
html
  head
    meta(charset='utf8')
    //- 使用变量
    title= title
  body
    //- 使用变量并调用小写转大写方法    
    h1= hw.toUpperCase()

```

- cd到项目根目录 执行 `pug index.html -P -w -O test.json`

**编译后的index.html** 如下
```HTML
<html>
  <head>
    <meta charset="utf8">
    <title>命令行读取Json文件</title>
  </head>
  <body>
    <h1>HELLO WORLD</h1>
  </body>
</html>
```

--------------------------------

## 安全转义与非转义

- 默认情况下, 所有属性都是转义的-即, 特殊字符被替换为转义序列-以防止攻击 (如跨站点脚本)。
- 如果需要使用特殊字符, 请使用`!=`而不是`=`。

如下
```
doctype html
html
  head
    meta(charset='utf8')
    //- 声明变量  
    - var title = '安全转义与非转义'
    - var htmlData = '<script>document.getElementById("hid").style.color="blue";</script>'
    // json中的title值将会被内部声明的title覆盖
    title= title
  body
    //- 使用变量并调用小写转大写方法    
    h1#hid= hw
    //- 直接输出htmlData #{htmlData}
    p= htmlData
    //- 转义htmlData !{htmlData}
    p!= htmlData
    // 同其他编程语言一样可以使用 \ 符号转义输出特殊含义的符号
    p #{hw}
    p \#{hw}

```
使用`pug index.html -P -w -O test.json`
编译后的HTML如下
```HTML
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf8">
    <!-- json中的title值将会被内部声明的title覆盖-->
    <title>安全转义与非转义</title>
  </head>
  <body>
    <h1 id="hid">Hello World</h1>
    <p>&lt;script&gt;document.getElementById(&quot;hid&quot;).style.color=&quot;blue&quot;;&lt;/script&gt;</p>
    <p><script>document.getElementById("hid").style.color="blue";</script></p>
    <!-- 同其他编程语言一样可以使用 \ 符号转义输出 特殊含义的符号-->
    <p>Hello World</p>
    <p>#{hw}</p>
  </body>
</html>
```

--------------------------------

## 流程代码

### [each AND while AND for ](https://pugjs.org/language/iteration.html)

- Pug支持两种主要的迭代方法： **each** 和 **while**

- Pug的‎‎ first-class ‎‎迭代语法可以更容易地遍历模板中的数组和对象。

如
```
ul
  each val in [1, 2, 3, 4, 5]
    li= val
```
编译成
```HTML
<ul>
  <li>1</li>
  <li>2</li>
  <li>3</li>
  <li>4</li>
  <li>5</li>
</ul>
```

- 你也可以获取数组索引及其对应的值。

如
```
ul
  each val, index in ['zero', 'one', 'two']
    li= index + ': ' + val
```
编译成
```HTML
<ul>
  <li>0: zero</li>
  <li>1: one</li>
  <li>2: two</li>
</ul>
```
- Pug还允许您遍历对象中的键:

如
```
ul
  each val, index in {1:'one',2:'two',3:'three'}
    li= index + ': ' + val
```
编译成
```HTML
<ul>
  <li>1: one</li>
  <li>2: two</li>
  <li>3: three</li>
</ul>
```

- 要遍历的对象或数组只是简单的 JavaScript。因此, 它可以是一个变量, 或者是函数调用的结果, 或者是其他任何东西。

如
```
- var values = [];
ul
  each val in values.length ? values : ['There are no values']
    li= val
```
编译成
```HTML
<ul>
  <li>There are no values</li>
</ul>
```

- 如果数组或对象不包含要循环访问的值, 则还可以添加一个将执行的 `else` 块。以下与上面的示例等效。

如
```
- var values = [];
ul
  each val in values
    li= val
  else
    li There are no values
```
编译成
```HTML
<ul>
  <li>There are no values</li>
</ul>
```

### for

- 你也可以使用 `each`的别名 `for`

如
```
- var values = [];
ul
  for val in values
    li= val
  else
    li There are no values
```
等价于
```
- var values = [];
ul
  each val in values
    li= val
  else
    li There are no values
```

### while

- 你还可以使用`while`创建循环

如
```
- var n = 0;
ul
  while n < 4
    li= n++
```
编译成
```HTML
<ul>
  <li>0</li>
  <li>1</li>
  <li>2</li>
  <li>3</li>
</ul>
```

### [Case](https://pugjs.org/language/case.htm)

- 该语句是 JavaScript 语句的简写。它采用以下形式:`case switch`

如
```
- var friends = 10
case friends
  when 0
    p you have no friends
  when 1
    p you have a friend
  default
    p you have #{friends} friends
```
编译成
```html
<p>you have 10 friends</p>
```

- 同JavaScript中的switch一样如果没有break中断语句，代码将会一直执行

如
```
- var friends = 0
case friends
  when 0
  when 1
    p you have very few friends
  default
    p you have #{friends} friends
```
编译成
```html
<p>you have very few friends</p>
```

- ***值得注意的是 **break** 语句，同 **var** 语句一样需要加上短杠 `-`***

如
```
- var friends = 0
case friends
  when 0
    - break
  when 1
    p you have very few friends
  default
    p you have #{friends} friends
```
编译成
```html

```
之所以为空，是因为在选中`when 0`后 被 `- break` 中断了迭代，而选中的`when 0` 没有任何 `block`块。

- **你还可以使用Block Expansion（扩展块）**

如
```
- var friends = 1
case friends
  when 0: p you have no friends
  when 1: p you have a friend
  default: p you have #{friends} friends
```
编译成
```html
<p>you have a friend</p>
```



### if else 以及 unless

- **Pug的 first-class 条件语法允许可选的括号。
在Pug1.0版本以及以上版本，可以省略 短杠`-`，就像不同的JavaScript一样。**

如
```
- var user = { description: 'foo bar baz' }
- var authorised = false
#user
  if user.description
    h2.green Description
    p.description= user.description
  else if authorised
    h2.blue Description
    p.description.
      User has no description,
      why not add one...
  else
    h2.red Description
    p.description User has no description
```
编译成
```html
<div id="user">
  <h2 class="green">Description</h2>
  <p class="description">foo bar baz</p>
</div>
```

- **Pug也提供一个unless（除非）条件语法，它像是一个否定语句。**

`unless isTrue()` 等价于`if !isTrue()`
如
```
unless user.isAnonymous
  p You're logged in as #{user.name}
```
等价于
```
if !user.isAnonymous
  p You're logged in as #{user.name}
```

--------------------------------

## [Filters](https://pugjs.org/language/filters.html)（过滤器）

- 过滤器允许您在Pug模板中使用其他语言。他们把一个 **block** 作为纯文本输入。
- 若要将选项传递给过滤器, 请在过滤器名称后的括号内添加它们 (就像使用[tag attributes](https://pugjs.org/language/attributes.html)一样): ``:less(ieCompat=false)``
- 所有[JSTransformer](https://www.npmjs.com/browse/keyword/jstransformer)模块都可以用作Pug Filters。流行的过滤器包括 ``:babel, :uglify-js, :scss, 和 :markdown-it``.
- 如果找不到适合您的用例的过滤器, 则可以编写自己的[自定义过滤器][https://pugjs.org/language/filters.html#custom-filters]。

例如, 如果您希望能够在您的Pug模板中使用 CoffeeScript 和Markdown (使用Markdown渲染器), 则首先要确保安装了这些功能:
```npm
$ npm install --save jstransformer-coffee-script
$ npm install --save jstransformer-markdown-it
```
现在, 您应该能够呈现以下模板:

<pre style="float:left">
````
:markdown-it(linkify langPrefix='highlight-')
  # Markdown

  Markdown document with http://links.com and

  ```js
  var codeBlocks;
  ```
script
  :coffee-script
    console.log 'This is coffee script'
````
</pre>

</br>
<pre>
```
<html>
      <head>
        <meta charset="utf8">
        <title>变量声明和数据传递</title>
        </head>
        <body>
        <h1>HELLO WORLD</h1>
      </body>
</html>
```
</pre>


------------------------------


## Includes(插入模板)
```
 ███████████    ███████    ██████████      ███████
░█░░░███░░░█  ███░░░░░███ ░░███░░░░███   ███░░░░░███
░   ░███  ░  ███     ░░███ ░███   ░░███ ███     ░░███
    ░███    ░███      ░███ ░███    ░███░███      ░███
    ░███    ░███      ░███ ░███    ░███░███      ░███
    ░███    ░░███     ███  ░███    ███ ░░███     ███
    █████    ░░░███████░   ██████████   ░░░███████░
   ░░░░░       ░░░░░░░    ░░░░░░░░░░      ░░░░░░░
```

<!--
 #######
    #    ###### #    # #####  #        ##   ##### ######
    #    #      ##  ## #    # #       #  #    #   #
    #    #####  # ## # #    # #      #    #   #   #####
    #    #      #    # #####  #      ######   #   #
    #    #      #    # #      #      #    #   #   #
    #    ###### #    # #      ###### #    #   #   ######

-->

----------------------

## [Template Inheritance](https://pugjs.org/language/inheritance.html)（模板继承）

- Pug支持模板继承。模板继承通过关键字 `block` 和 `extends` 实现。

- **在一个模板中，一个block只是一个简单的、可以被替换的子模板。此过程是递归的**

- 如果合适的话, Pug blocks可以提供默认的内容。不过, 提供的默认内容是完全可选的。下面的示例定义`block scripts`、`block content`和`block foot`。

新建一个文件 命名为layout.pug

内容如下
```
//- layout.pug
html
  head
    meta(charset='utf8')
    title My Site - #{title}
    //- 定义了一个block(子模板)： scripts block
    block scripts
      script(src='/jquery.js')
  body
    //- 定义了一个block(子模板)： content block
    block content
    //- 定义了一个block(子模板)： foot block
    block foot
      #footer
        p some footer content
```
cd 项目根目录 命令行执行 `pug layout.pug -P -w`
编译后的layout.html如下
```
<html>
  <head>
    <meta charset="utf8"/>
    <title>My Site - </title>
    <script src="/jquery.js"></script>
  </head>
  <body>
    <div id="footer">
      <p>some footer content</p>
    </div>
  </body>
</html>
```

**若要扩展此布局, 请创建一个新文件, 并使用关键字`extends`指向父模板的路径的指令。(如果未提供文件扩展名`.pug`, 则会自动追加到文件名中。）然后, 定义一个或多个块以覆盖父块内容。**

- 下面, 请注意, 这个`foot` block没有被重新定义, 因此它将使用父级的默认值并输出 "some footer content"。

在项目根目录新建 **page-a.pug**
内容如下
```
//- page-a.pug
//- 继承了layout.pug 模板
extends layout.pug
//- 重写了一个block(子模版）： scripts block
block scripts
  script(src='/jquery.js')
  script(src='/pets.js')
//- 重写了一个block（子模版）： content block
block content
  h1= title
  - var pets = ['cat', 'dog']
  each petName in pets
    //- 将数组迭代输出的值插入到一个模板中：pet.pug
    include pet.pug
```
继续新建一个 **pet.pug**
内容如下
```
//- pet.pug
p= petName
```
cd 项目根目录 命令行执行 `pug page-a.pug -P -w`
编译后的page-a.html如下
```
<html>
  <head>
    <meta charset="utf8"/>
    <title>My Site - </title>
    <script src="/jquery.js"></script>
    <script src="/pets.js"></script>
  </head>
  <body>
    <h1></h1>
    <p>cat</p>
    <p>dog</p>
    <div id="footer">
      <p>some footer content</p>
    </div>
  </body>
</html>
```
**因为page-a.pug extends（继承了）layout.pug
所以在将page-a.pug编译后生成的page-a.html中就拥有了layout.pug中的pug元素节点（html、head
meta、title）。而同样继承过来的script、以及content的block却被page-a.pug 给redefined（重写）了。**

对比layout.html与page-a.html，可以看见的，重写的script block以及content block中的内容被替换了，而not redefined（未重写）的foot block 却是按照layout.pug中定义的那样给编译输出来了。

- 你还可以继承模板然后重写它的子模版以提供更多的模板

如
```
//- sub-layout.pug
extends layout.pug

block content
  .sidebar
    block sidebar
      p nothing
  .primary
    block primary
      p nothing
```

```
//- page-b.pug
extends sub-layout.pug

block content
  .sidebar
    block sidebar
      p nothing
  .primary
    block primary
      p nothing
```


### Block append / prepend

- Pug 允许你在继承模板的原有子模板上使用关键字`prepend`or `append`添加子模板

- 使用append会添加到原有子模板的后面，而使用prepend会添加到原有子模板的前面。

假设您的`head block`中有希望在每个页上使用的默认脚本。您可以这样做:
```
//- layout.pug
html
  head
    block head
      script(src='/vendor/jquery.js')
      script(src='/vendor/caustic.js')
  body
    block content
```
现在, 考虑一下你的 JavaScript 游戏的页面。您需要一些与游戏相关的脚本以及这些默认值。您可以简单通过地通过`append`添加:
```
//- page.pug
extends layout.pug

block append head
  script(src='/vendor/three.js')
  script(src='/game.js')
```

- 使用 `block append` or`block prepend` 时, 单词 "block" 是可选的。

如以下写法和上面的写法是效果一致的
```
//- page.pug
extends layout

append head
  script(src='/vendor/three.js')
  script(src='/game.js')
```

### Common mistakes （常见错误）

>   Pug’s template inheritance is a powerful feature    that allows you to split complex page template structures into smaller, simpler files. However, if you chain many, many templates together, you can make things a lot more complicated for yourself.
>  
>   Note that only named blocks and mixin definitions can appear at the top (unindented) level of a child template. This is important! Parent templates define a page’s overall structure, and child templates can only append, prepend, or replace specific blocks of markup and logic. If a child template tried to add content outside of a block, Pug would have no way of knowing where to put it in the final page.
>  
>  This includes unbuffered code, which can also contain markup. If you need to define variables for use in a child template, you can do so a few different ways:
>  1. Add the variables to the Pug options object, or define them in unbuffered code in a parent template. The child template will inherit these variables.
>  
>  2. Define the variables in a block in the child template. Extending templates must have at least one block, or it would be empty — just define your variables there.


>  For the same reason, Pug’s buffered comments cannot appear at the top level of an extending template: they produce HTML comments which would have nowhere to go in the resulting HTML. (Unbuffered Pug comments, however, can still go anywhere.)

下面是机翻：
> 帕格的模板继承是一个强大的功能, 允许您将复杂的页面模板结构拆分为更小、更简单的文件。但是, 如果您将许多模板链接在一起, 则可以使您自己的情况变得复杂很多。
>
请注意,只有命名块和 mixin 定义才能显示在子模板的顶部 (缩) 级别。这很重要!父模板定义页的整体结构, 子模板只能、或替换特定的标记和逻辑块。如果子模板试图在块之外添加内容, 帕格将无法知道将其放在最后一页的什么地方。appendprepend
>
>这包括缓冲代码, 它也可以包含标记。如果需要定义用于子模板的变量, 可以采用几种不同的方法:
>
> 1. 将变量添加到帕格options对象中, 或者在父模板的缓冲代码中定义它们。子模板将继承这些变量。
>
> 2. 在子模板中定义块中的变量。扩展模板必须至少有一个块, 否则它将是空的-只需在那里定义变量。


>出于同样的原因, 帕格的缓冲注释不能出现在扩展模板的顶层: 它们产生的 html 注释在结果 html 中无处可去。(缓冲帕格的评论, 但是, 仍然可以去任何地方。

--------------------------------

## 黑魔法 mixin

- **mixin 允许您创建可重用的block of pug(pug的代码块)。**

如
```
//- Declaration（声明）
mixin list
  ul
    li foo
    li bar
    li baz
//- Use（使用）
+list
+list
```
编译成
```
<ul>
  <li>foo</li>
  <li>bar</li>
  <li>baz</li>
</ul>
<ul>
  <li>foo</li>
  <li>bar</li>
  <li>baz</li>
</ul>
```

- **mixin 被Pug引擎视作为函数, 所以可以接受参数。**

如
```
mixin pet(name)
  li.pet= name
ul
  +pet('cat')
  +pet('dog')
  +pet('pig')
```
编译成
```HTML
<ul>
  <li class="pet">cat</li>
  <li class="pet">dog</li>
  <li class="pet">pig</li>
</ul>
```

### Mixin Blocks（块）

- **mixin 也可以采取一个 block of Pug (pug的代码块)作为内容。**

如
```
mixin article(title)
  .article
    .article-wrapper
      h1= title
      if block
        block
      else
        p No content provided

+article('Hello world')

+article('Hello world')
  p This is my
  p Amazing article
```
编译成
```HTML
<div class="article">
  <div class="article-wrapper">
    <h1>Hello world</h1>
    <p>No content provided</p>
  </div>
</div>
<div class="article">
  <div class="article-wrapper">
    <h1>Hello world</h1>
    <p>This is my</p>
    <p>Amazing article</p>
  </div>
</div>
```

### Mixin Attributes（属性）

- mixin 还得到一个隐式参数：**attributes**, 它取自传递给 mixin 的属性。

如
```
mixin link(href, name)
  //- attributes == {class: "btn"}
  a(class!=attributes.class href=href)= name

+link('/foo', 'foo')(class="btn")
```
编译成
```
<a class="btn" href="/foo">foo</a>
```

**Note(注意)**
**默认值属性已被转义!你应该使用`！=` 避免转义。(请参见[unescaped attributes](https://pugjs.org/language/attributes.html#unescaped-attributes) (转义属性)。**

- 也可以将 mixin 与 ``&`` 属性一起使用。

如
```
mixin link(href, name)
  a(href=href)&attributes(attributes)= name

+link('/foo', 'foo')(class="btn")
```
编译成
```HTML
<a class="btn" href="/foo">foo</a>
```
**Note(注意)**
**`+link(class="btn")`语法也是有效的, 等同于``+link()(class="btn")`` ,因为Pug试图检测括号的内容是否为属性或参数。不过, 我们建议您使用第二个语法, 因为您没有显式传递参数, 并且确保第一个括号是参数列表。**

### Rest Arguments（Rest 参数）

- 您可以使用 "rest 参数" 语法编写 mixin, 该参数采用了未知数目的实参

如
```
mixin list(id, ...items)
  ul(id=id)
    each item in items
      li= item

+list('my-list', 1, 2, 3, 4)
```
编译成
```HTML
<ul id="my-list">
  <li>1</li>
  <li>2</li>
  <li>3</li>
  <li>4</li>
</ul>
```


[JadeVideo]: <http://www.imooc.com/comment/259> (带你学习Jade模板引擎)
[Pug]: <https://github.com/pugjs/pug> (README.md)
[Pugjs]: <https://pugjs.org/language/attributes.html> (Pugjs官网)
